<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ì„ ëŒ€ì¹­/ì ëŒ€ì¹­ë„í˜• ì™„ì „ ì •ë³µ</title>
    <meta property="og:title" content="ì„ ëŒ€ì¹­/ì ëŒ€ì¹­ë„í˜• ì™„ì „ ì •ë³µ">
    <meta property="og:description" content="ì„ ëŒ€ì¹­, ì ëŒ€ì¹­ë„í˜• ë¬¸ì œë¥¼ ì—°ìŠµí•´ë³´ì„¸ìš”!">
    <meta property="og:image" content="https://3arch2nd.github.io/symmetry/thumb.png">
    <meta property="og:url" content="https://3arch2nd.github.io/symmetry/">
    <meta property="og:type" content="website">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Gowun+Dodum&display=swap" rel="stylesheet">
    <style>
/* ê¸°ë³¸ ìŠ¤íƒ€ì¼ */
body {
    font-family: 'Gowun Dodum', sans-serif;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    margin: 0;
    background-color: #f4f7f6;
    color: #333;
    text-align: center;
}
.container {
    position: relative;
    background-color: white;
    padding: 30px;
    border-radius: 12px;
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
    width: 90%;
    max-width: 800px;
    text-align: center;
    margin: 20px auto;
    box-sizing: border-box;
}
h1 {
    color: #4b8134;
    margin-bottom: 20px;
    font-size: 2em;
}
h2 {
    margin-bottom: 5px;
}
small {
    display: block;
    font-size: 18px;
    color: #6c757d;
    margin-bottom: 20px;
    line-height: 1.5;
}
button {
    font-family: 'Gowun Dodum', sans-serif;
    padding: 10px 20px;
    margin: 5px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.3s, transform 0.1s;
}
button:hover {
    transform: translateY(-1px);
}
.primary-btn {
    background-color: #a0c179;
    color: white;
}
.primary-btn:hover {
    background-color: #8cb24b;
}
.secondary-btn {
    background-color: #e9e9e9;
    color: #333;
    border: none;
}
.secondary-btn:hover {
    background-color: #d9d9d9;
}
#clear-canvas-btn {
    background-color: #ea9999;
    color: white;
}
#clear-canvas-btn:hover {
    background-color: #e06666;
}
.mode-btn-active {
    background-color: #ffc107;
    color: #333;
    font-weight: bold;
}
#setup-page, #problem-page, #final-result-page {
    display: none;
}
#setup-page {
    display: flex;
    flex-direction: column;
    gap: 20px;
}
.setting-group {
    border: 1px solid #ddd;
    padding: 15px;
    border-radius: 8px;
    text-align: center;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    box-sizing: border-box;
    flex-grow: 1;
}
.option-buttons {
    display: flex;
    flex-direction: row;
    justify-content: center;
    gap: 5px;
    margin-top: 10px;
}
.option-buttons button {
    flex-grow: 1;
    padding: 10px 20px;
}
.option-buttons button.selected {
    background-color: #ffc107;
    color: #333;
    font-weight: bold;
}

.canvas-wrapper {
    position: relative;
    display: block;
    margin: 0 auto 20px auto;
    width: 100%;
    max-width: 400px;
    height: auto;
    aspect-ratio: 1 / 1;
    border: 2px solid #333;
    box-sizing: border-box;
}
#grid-canvas {
    background-color: white;
    cursor: crosshair;
    width: 100%;
    height: 100%;
    display: block;
    -webkit-tap-highlight-color: transparent;
}

.user-dot {
    width: 8px;
    height: 8px;
    background-color: #dc3545;
    border-radius: 50%;
    position: absolute;
    transform: translate(-50%, -50%);
    pointer-events: none;
    box-shadow: 0 0 3px rgba(0,0,0,0.5);
    z-index: 10;
}
.problem-dot, .line-dot {
    width: 8px;
    height: 8px;
    background-color: black;
    border-radius: 50%;
    position: absolute;
    transform: translate(-50%, -50%);
    pointer-events: none;
    box-shadow: 0 0 3px rgba(0,0,0,0.5);
    z-index: 10;
}
.selected-line-dot {
    width: 10px;
    height: 10px;
    background-color: #ff0000;
    border-radius: 50%;
    position: absolute;
    transform: translate(-50%, -50%);
    pointer-events: none;
    box-shadow: 0 0 5px rgba(255,0,0,0.8);
    z-index: 11;
}
.canvas-controls {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
    margin-bottom: 20px;
}
.correct, .incorrect {
    padding: 10px;
    border-radius: 8px;
    font-weight: bold;
    margin-top: 15px;
}
.correct { color: #28a745; }
.incorrect { color: #dc3545; }

#quantity-control {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 15px;
}
#quantity-control button {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    padding: 0;
    margin: 0;
    font-size: 20px;
    font-weight: bold;
    line-height: 30px;
    background-color: #f0f0f0;
    border: 1px solid #ccc;
    color: #333;
}
#quantity-control button:hover {
    background-color: #e0e0e0;
}
.quantity-display {
    display: inline-block;
    width: auto;
    min-width: 40px;
    height: auto;
    background-color: transparent;
    border-radius: 0;
    font-size: 24px;
    font-weight: bold;
    color: #333;
    box-shadow: none;
    vertical-align: baseline;
    margin: 0;
    text-align: center;
}

.footer {
    margin-top: 20px;
    font-size: 12px;
    color: #ccc;
    text-align: center;
}

.main-layout {
    display: flex;
    flex-direction: row;
    gap: 20px;
    width: 100%;
    max-width: 800px;
    align-items: stretch;
    flex-wrap: wrap;
}
.main-layout h3 {
    text-align: center;
}
.left-panel {
    flex: 2;
    display: flex;
    flex-direction: column;
    gap: 20px;
}
.right-panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 20px;
}
.right-panel .setting-group, .left-panel .setting-group {
    flex-grow: 1;
}

#start-quiz-btn {
    width: 100px;
    height: 100px;
    border-radius: 50%;
    font-size: 20px;
    font-weight: bold;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 0;
    flex-shrink: 0;
}

.setting-group.start-btn-container {
    border: none;
    background-color: transparent;
}

.problem-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}
.home-button {
    background-color: #e9e9e9;
    color: #333;
    border-radius: 8px;
    padding: 8px 12px;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 5px;
    cursor: pointer;
    text-decoration: none;
    transition: background-color 0.3s;
}
.home-button:hover {
    background-color: #d9d9d9;
}
#problem-number {
    flex-grow: 1;
    text-align: center;
    margin: 0;
}

.problem-footer {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    width: 100%;
    margin-top: 20px;
}

.popup-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 100;
}
.popup-box {
    background-color: white;
    padding: 30px;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    position: relative;
    width: 80%;
    max-width: 450px;
    text-align: center;
    /* ì¶”ê°€ëœ ë¶€ë¶„ */
    display: flex;
    flex-direction: column;
    align-items: center;
}
.popup-box .close-btn {
    position: absolute;
    top: 10px;
    right: 15px;
    font-size: 28px;
    font-weight: bold;
    color: #333;
    cursor: pointer;
    background: none;
    border: none;
    padding: 0;
}
.popup-box .close-btn:hover { color: #6c757d; }

.result-popup #popup-main-message {
    font-size: 1.2em;
    font-weight: bold;
    margin-bottom: 0;
    line-height: 1.5;
}
.result-popup #popup-detail-message { display: none; }
.result-popup #popup-next-btn { margin-top: 20px; }

.final-result-layout {
    display: flex;
    flex-direction: row;
    justify-content: space-around;
    align-items: center;
    margin: 30px 0;
    gap: 20px;
}
.result-left, .result-right {
    flex: 1;
    padding: 20px;
}
.result-left {
    border-right: 1px solid #ddd;
}
.result-right p {
    font-size: 1.1em;
    margin: 15px 0;
}
#final-accuracy {
    font-size: 4em;
    font-weight: bold;
    color: #4b8134;
    margin-top: 10px;
}
        /* *** ìµœì¢… ì ìˆ˜ ìŠ¤íƒ€ì¼ ì¶”ê°€ *** */
.score-display {
    margin-top: 20px;
    font-size: 1.1em;
    font-weight: bold;
}
#final-score {
    font-size: 1.4em;
    font-weight: bold;
    color: #4b8134;
    display: inline-block;
    margin-left: 5px;
}

#qr-code-btn {
    position: absolute;
    top: 15px;
    right: 15px;
    padding: 5px 10px;
    font-size: 14px;
    z-index: 20;
}
#qr-popup-overlay { 
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(255, 255, 255, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 200;
}
.popup-qr {
    background-color: white;
    padding: 40px;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    position: relative;
    text-align: center;
}
.popup-qr img {
    max-width: 180px; /* ì´ ë¶€ë¶„ì„ 200pxì—ì„œ 120pxë¡œ ìˆ˜ì •í–ˆìŠµë‹ˆë‹¤. */
    height: auto;
}
.popup-qr p {
    margin-top: 15px;
    color: #666;
}
.close-btn-qr {
    position: absolute;
    top: 10px;
    right: 15px;
    font-size: 28px;
    font-weight: bold;
    color: #333;
    cursor: pointer;
    background: none;
    border: none;
    padding: 0;
}

#hof-popup-overlay { background-color: rgba(0, 0, 0, 0.2); }
.hof-input-group { margin: 20px 0; }
.hof-input-group input {
    font-family: 'Gowun Dodum', sans-serif;
    font-size: 18px;
    padding: 8px;
    width: 80px;
    text-align: center;
    border: 1px solid #ccc;
    border-radius: 4px;
    margin-right: 10px;
    text-transform: uppercase;
}
.hof-table-container { max-height: 300px; overflow-y: auto; margin-top: 20px;}
#hof-table { width: 100%; border-collapse: collapse; }
#hof-table th, #hof-table td { padding: 8px; border-bottom: 1px solid #eee; }
#hof-table th { background-color: #f8f9fa; }

.mobile-title, .mobile-home { display: none; }

@media (max-width: 768px) {
    .main-layout { flex-direction: column; }
    .left-panel, .right-panel { width: 100%; margin-top: 20px; }
    .option-buttons { flex-direction: column; }
    .problem-footer { justify-content: center; }
    .final-result-layout { flex-direction: column; }
    .result-left { border-right: none; border-bottom: 1px solid #ddd; width: 100%; }
}

@media (max-width: 480px) {
    .container {
        padding: 15px;
    }
    .desktop-title { display: none; }
    .mobile-title { display: inline; }
    .desktop-home { display: none; }
    .mobile-home { display: inline; }
    .home-button { padding: 8px 10px; }
}

/* ì´ ì½”ë“œë¥¼ ê¸°ì¡´ style íƒœê·¸ ì•ˆìª½ì— ì¶”ê°€í•´ì£¼ì„¸ìš” */
.confirm-clear-popup p {
    font-size: 1.1em;
    margin-bottom: 25px; /* ë²„íŠ¼ê³¼ì˜ ê°„ê²© */
    line-height: 1.6;
}
.confirm-buttons {
    display: flex;
    justify-content: center;
    gap: 15px; /* ë²„íŠ¼ ì‚¬ì´ ê°„ê²© */
    width: 100%;
}
.confirm-buttons button {
    padding: 10px 30px; /* ë²„íŠ¼ í¬ê¸° */
    font-weight: bold;
}
#confirm-clear-yes-btn {
    background-color: #e06666; /* ë¹¨ê°„ìƒ‰ ê³„ì—´ */
    color: white;
}
#confirm-clear-yes-btn:hover {
    background-color: #cc4125;
}

</style>
</head>
<body>

<div class="container">
    <button id="qr-code-btn" class="secondary-btn">QR ì½”ë“œ</button>
    <div id="setup-page">
        <h1>
            <span class="desktop-title">ì„ ëŒ€ì¹­/ì ëŒ€ì¹­ë„í˜• ì™„ì „ ì •ë³µ</span>
            <span class="mobile-title">ì„ ëŒ€ì¹­/ì ëŒ€ì¹­ë„í˜•<br>ì™„ì „ ì •ë³µ</span>
        </h1>
        <h2 style="text-align: center;">ë¬¸ì œ ìœ í˜• ë° ê°œìˆ˜ ì„¤ì •</h2>
        <small>ë¬´ì‘ìœ„ë¡œ ìƒì„±ë˜ëŠ” ìƒˆë¡œìš´ ë¬¸ì œë¥¼ <br> ì›í•˜ëŠ” ë§Œí¼ ì—°ìŠµí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. <br> (ìµœì†Œ 5, ìµœëŒ€ 50ë¬¸ì œ)</small>

        <div class="main-layout">
            <div class="left-panel">
                <div class="setting-group">
                    <h3>ë¬¸ì œ ìœ í˜• ì„ íƒ</h3>
                    <div id="type-select" class="option-buttons">
                        <button data-type="line" class="selected">ì„ ëŒ€ì¹­ë„í˜•</button>
                        <button data-type="point">ì ëŒ€ì¹­ë„í˜•</button>
                        <button data-type="both">ë‘˜ ë‹¤ í• ë˜ìš”</button>
                    </div>
                </div>
                <div class="setting-group">
                    <h3>ë‚œì´ë„ ì„ íƒ</h3>
                    <div id="difficulty-select" class="option-buttons">
                        <button data-difficulty="1" class="selected">â˜…</button>
                        <button data-difficulty="2">â˜…â˜…</button>
                    </div>
                </div>
            </div>
            <div class="right-panel">
                <div class="setting-group">
                    <h3>ë¬¸ì œ ê°œìˆ˜ ì„¤ì •</h3>
                    <div id="quantity-control">
                        <button id="quantity-minus">-</button>
                        <span id="problem-quantity" class="quantity-display">5</span>
                        <button id="quantity-plus">+</button>
                    </div>
                </div>
                <div class="setting-group start-btn-container">
                    <button id="start-quiz-btn" class="primary-btn">ì‹œì‘!</button>
                </div>
            </div>
        </div>
    </div>
    
    <div id="problem-page">
        <div class="problem-header">
            <button class="home-button">
                <span class="desktop-home">ğŸ  ì²« í˜ì´ì§€ë¡œ</span>
                <span class="mobile-home">ğŸ </span>
            </button>
            <h2 id="problem-number">1ë²ˆì§¸ ë¬¸ì œ</h2>
            <div style="width: 120px;"></div>
        </div>
        <p id="problem-instruction">ì•„ë˜ ë„í˜•ì€ ì„ ëŒ€ì¹­ë„í˜•ì…ë‹ˆë‹¤. ë‚˜ë¨¸ì§€ ë¶€ë¶„ì„ ì™„ì„±í•´ ì£¼ì„¸ìš”.</p>
        
        <div class="canvas-wrapper">
            <canvas id="grid-canvas" width="400" height="400"></canvas>
        </div>

        <div class="canvas-controls">
            <button id="mode-vertex" class="secondary-btn mode-btn-active" onclick="setCanvasMode('vertex')">1ë‹¨ê³„: ê¼­ì§“ì  ì°ê¸°</button>
            <button id="mode-line" class="secondary-btn" onclick="setCanvasMode('line')" disabled>2ë‹¨ê³„: ì„ ë¶„ ì‡ê¸°</button>
            <button id="clear-canvas-btn" class="secondary-btn">ë‹¤ì‹œ í’€ê¸° (ì´ˆê¸°í™”)</button>
        </div>

        <div class="problem-footer">
            <button id="check-answer-btn" class="primary-btn" onclick="checkAnswer()">ì •ë‹µ í™•ì¸í•˜ê¸°</button>
            <button id="next-problem-btn" class="primary-btn" style="display: none;">ë‹¤ìŒ ë¬¸ì œ ë„ì „í•˜ê¸°</button>
        </div>
    </div>

    <div id="final-result-page">
        <h2>í•™ìŠµ ì™„ë£Œ</h2>
        <div class="final-result-layout">
            <div class="result-left">
                <p>ë‚˜ì˜ ì •í™•ë„</p>
                <div id="final-accuracy">0%</div>
            </div>
            <div class="result-right">
                <p>í•œ ë²ˆì— ë§ì¶˜ ë¬¸ì œ: <span id="correct-count">0</span>ê°œ</p>
                <p>ë‹¤ì‹œ ë„ì „í•´ ë§ì¶˜ ë¬¸ì œ: <span id="retried-count">0</span>ê°œ</p>
                <p class="score-display">ìµœì¢… ì ìˆ˜: <span id="final-score">0</span>ì </p>
            </div>
        </div>
        <div>
            <button class="primary-btn" onclick="location.reload()">ìƒˆë¡œìš´ í•™ìŠµ ì‹œì‘í•˜ê¸°</button>
            <button id="show-hof-btn" class="secondary-btn">ğŸ† ëª…ì˜ˆì˜ ì „ë‹¹ ë“±ë¡í•˜ê¸°</button>
        </div>
    </div>
</div>
<div class="footer">
    íœ´ë¥´ìŒ¤
</div>

<div id="result-popup-overlay" class="popup-overlay" style="display: none;">
    <div class="result-popup popup-box">
        <button class="close-btn" onclick="closePopup()">&times;</button>
        <div class="popup-content">
            <p id="popup-main-message"></p>
            <p id="popup-detail-message"></p>
            <button id="popup-next-btn" class="primary-btn" onclick="nextProblem()">ë‹¤ìŒ ë¬¸ì œ ë„ì „í•˜ê¸°</button>
        </div>
    </div>
</div>

<div id="qr-popup-overlay" class="popup-overlay" style="display: none;">
    <div class="popup-qr popup-box">
        <button class="close-btn" onclick="closeQrPopup()">&times;</button>
        <img src="https://i.imgur.com/g4yS8yx.png" alt="QR Code">
    </div>
</div>

<div id="hof-popup-overlay" class="popup-overlay" style="display: none;">
    <div class="popup-hof popup-box">
        <button class="close-btn" onclick="closeHofPopup()">&times;</button>
        <h3>ğŸ† ëª…ì˜ˆì˜ ì „ë‹¹</h3>
        <div class="hof-input-group">
            <input type="text" id="hof-initial" placeholder="AAA" maxlength="3" oninput="this.value = this.value.toUpperCase().replace(/[^A-Z]/g, '')">
            <button id="hof-submit-btn" class="primary-btn">ë“±ë¡</button>
        </div>
        <div id="hof-message"></div>
        <div class="hof-table-container">
            <table id="hof-table">
                <thead>
                    <tr>
                        <th>ìˆœìœ„</th>
                        <th>ì´ë‹ˆì…œ</th>
                        <th>ì ìˆ˜</th>
                    </tr>
                </thead>
                <tbody>
                </tbody>
            </table>
        </div>
    </div>
</div>

<script>
    // *** Cloudflare Worker URLì„ ì—¬ê¸°ì— ë¶™ì—¬ë„£ìœ¼ì„¸ìš”! ***
    const webAppUrl = 'https://soft-wood-cf8e.bbglara.workers.dev/';

    // ì „ì—­ ë³€ìˆ˜ ì„¤ì •
    let selectedType = 'line';
    let totalProblems = 5;
    let currentProblem = 0;
    let canvasMode = 'vertex';
    let score = { results: [] }; // ë¬¸ì œë³„ ê²°ê³¼ë¥¼ ìƒì„¸íˆ ê¸°ë¡í•  ë°°ì—´
    let currentProblemAttempts = 0; // í˜„ì¬ ë¬¸ì œì˜ ì‹¤íŒ¨ íšŸìˆ˜ë¥¼ ê¸°ë¡
    let selectedDifficulty = 1;
    let finalAccuracyValue = 0;
    let hasSubmittedScore = false;
    
    const canvas = document.getElementById('grid-canvas');
    const ctx = canvas.getContext('2d');
    const canvasWrapper = document.querySelector('.canvas-wrapper');
    const GRID_SIZE = 20;
    const GRID_COUNT = canvas.width / GRID_SIZE;
    const HALF_COUNT = GRID_COUNT / 2;
    const CENTER_POINT = { x: HALF_COUNT, y: HALF_COUNT };
    const MIN_COORD = 3;
    const MAX_COORD = 17;
    const MIN_DIST = 2;
    
    const COLLINEARITY_THRESHOLD = 1.0;
    const MIN_ANGLE_COSINE = Math.cos(30 * Math.PI / 180);
    const MAX_ANGLE_COSINE = Math.cos(150 * Math.PI / 180);
    const MIN_SLOPE_DIFF = 2.0;

    let problemVertices = [];
    let problemLines = [];
    let userVertices = [];
    let userLines = [];
    let tempLineStart = null;
    let hoveredLine = null;
    let problemList = [];

    // í—¬í¼ í•¨ìˆ˜
    function isSamePoint(p1, p2) {
        if (!p1 || !p2) return false;
        return p1.x === p2.x && p1.y === p2.y;
    }
    
    function isSameLine(l1, l2) {
        if (!l1 || !l2) return false;
        const p11 = l1.p1;
        const p12 = l1.p2;
        const p21 = l2.p1;
        const p22 = l2.p2;
        
        return (isSamePoint(p11, p21) && isSamePoint(p12, p22)) || (isSamePoint(p11, p22) && isSamePoint(p12, p21));
    }
    
    function isLineExists(newLine) {
        return userLines.some(existingLine => isSameLine(existingLine, newLine));
    }

    function nextProblem() {
        closePopup();
        currentProblem++;
        loadProblem();
        saveGameState();
    }
    
    function getRandomInt(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    
    function isTooClose(newV, vertices, minDist = MIN_DIST) {
        const minDistSq = minDist ** 2;
        for (const v of vertices) {
            const distSq = (newV.x - v.x) ** 2 + (newV.y - v.y) ** 2;
            if (distSq < minDistSq) {
                return true;
            }
        }
        return false;
    }

    function isTooLinear(p1, p2, p3) {
        const crossProduct = (p2.y - p1.y) * (p3.x - p2.x) - (p3.y - p2.y) * (p2.x - p1.x);
        return Math.abs(crossProduct) < COLLINEARITY_THRESHOLD;
    }
    
    function isTooSharpAngle(p1, p2, p3) {
        const v1x = p1.x - p2.x;
        const v1y = p1.y - p2.y;
        const v2x = p3.x - p2.x;
        const v2y = p3.y - p2.y;

        const dotProduct = v1x * v2x + v1y * v2y;
        
        const mag1 = Math.sqrt(v1x * v1x + v1y * v1y);
        const mag2 = Math.sqrt(v2x * v2x + v2y * v2y);
        
        if (mag1 === 0 || mag2 === 0) return true;

        const cosine = dotProduct / (mag1 * mag2);
        
        if (cosine > MIN_ANGLE_COSINE || cosine < MAX_ANGLE_COSINE) return true;
        
        return false;
    }
    
    function isTooWeakSlope(p1, p2) {
        const dx = Math.abs(p2.x - p1.x);
        const dy = Math.abs(p2.y - p1.y);
        return (dx <= MIN_SLOPE_DIFF || dy <= MIN_SLOPE_DIFF) || (dx > 0 && dy > 0 && Math.abs(dy / dx) < 1);
    }
    
    function isProblemTooLinear(vertices, newV) {
        const len = vertices.length;
        if (len >= 2) {
            const p1 = vertices[len - 2];
            const p2 = vertices[len - 1];
            const p3 = newV;
            
            for (let i = 0; i < len - 1; i++) {
                if (isTooLinear(vertices[i], p2, p3)) {
                    return true;
                }
            }
            if (isTooLinear(p1, p2, p3)) {
                return true;
            }
        }
        return false;
    }
    
    function isProblemTooSharp(vertices, newV) {
        const len = vertices.length;
        if (len >= 2) {
            const p1 = vertices[len - 2];
            const p2 = vertices[len - 1];
            const p3 = newV;
            const isAxisPoint = (p) => p.x === HALF_COUNT || p.y === HALF_COUNT || (p.x === p.y);
            
            if (isAxisPoint(p1) && isAxisPoint(p2) && isAxisPoint(p3)) {
                return false;
            }
            
            for(let i=1; i<len; i++) {
                if(isTooSharpAngle(vertices[i-1], vertices[i], newV)) return true;
            }
            
            return isTooSharpAngle(p1, p2, p3);
        }
        return false;
    }
    
    function distSq(p1, p2) {
        return (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;
    }
    
    function calculateSymmetricPoint(v, type, isSlantedAxis = false, axisDirection = 'vertical') {
        let symX, symY;
        const C = HALF_COUNT;

        if (type === 'line') {
            if (isSlantedAxis) {
                symX = v.y;
                symY = v.x;
            } else if (axisDirection === 'horizontal') {
                symX = v.x;
                symY = 2 * C - v.y;
            } else { 
                symX = 2 * C - v.x;
                symY = v.y;
            }
        } else if (type === 'point') {
            symX = 2 * C - v.x;
            symY = 2 * C - v.y;
        } else {
            return v;
        }
        return { x: Math.round(symX), y: Math.round(symY) };
    }
    
    function createSequentialLines(vertices, close = false) {
        const lines = [];
        if (vertices.length < 2) return lines;
        
        const count = vertices.length;
        for (let i = 0; i < count; i++) {
            const p1 = vertices[i];
            const p2 = vertices[(i + 1) % count];
            
            if (!close && i === count - 1) break;
            
            lines.push({ p1: p1, p2: p2 });
        }
        return lines;
    }
    
    function findPointSymmetricBoundary(points) {
        if (points.length < 3) return points;
        const C = CENTER_POINT;
        
        const centerPoint = points.find(p => isSamePoint(p, C));
        const nonCenterPoints = points.filter(p => !isSamePoint(p, C));
        
        nonCenterPoints.sort((a, b) => {
            const angleA = Math.atan2(a.y - C.y, a.x - C.x);
            const angleB = Math.atan2(b.y - C.y, b.x - C.x);
            return angleA - angleB;
        });

        let sortedPoints = [];
        if (centerPoint) {
            sortedPoints.push(centerPoint);
        }
        sortedPoints = sortedPoints.concat(nonCenterPoints);
        
        const finalPoints = sortedPoints.filter((v, i, self) => i === self.findIndex((t) => isSamePoint(t, v)));

        return finalPoints;
    }

    function sortSlantedAxisVertices(vertices) {
        const axisPoints = vertices.filter(v => v.x === v.y).sort((a, b) => a.y - b.y);
        const nonAxisPoints = vertices.filter(v => v.x !== v.y);
        
        const center = {x: 10, y: 10};
        
        const p1 = axisPoints[0];
        const p2 = axisPoints[1];

        const belowAxis = nonAxisPoints.filter(p => p.y < p.x);
        const aboveAxis = nonAxisPoints.filter(p => p.y > p.x);
        
        belowAxis.sort((a,b) => {
            const angleA = Math.atan2(a.y - p1.y, a.x - p1.x);
            const angleB = Math.atan2(b.y - p1.y, b.x - p1.x);
            return angleA - angleB;
        });

        aboveAxis.sort((a,b) => {
            const angleA = Math.atan2(a.y - p2.y, a.x - p2.x);
            const angleB = Math.atan2(b.y - p2.y, b.x - p2.x);
            return angleB - angleA;
        });
        
        return [p1, ...belowAxis, p2, ...aboveAxis];
    }

    function generateRandomProblem(type) {
        const MAX_ATTEMPTS_PER_POINT = 100;
        const MAX_PROBLEM_ATTEMPTS = 100;
        
        if (type === 'line') {
            let nVertices, minCoord, maxCoord;
            let isSlantedAxis = false;
            let axisDirection = 'vertical';
            
            if (selectedDifficulty == 2) {
                isSlantedAxis = Math.random() < 0.5;
                if (isSlantedAxis) {
                    nVertices = getRandomInt(3, 4);
                    minCoord = 3;
                    maxCoord = 17;
                    axisDirection = 'slanted';
                } else {
                    nVertices = getRandomInt(5, 6);
                    minCoord = 2;
                    maxCoord = 18;
                    axisDirection = Math.random() < 0.5 ? 'vertical' : 'horizontal';
                }
            } else {
                isSlantedAxis = false;
                nVertices = 4; // Difficulty 1 fixed to 4 vertices
                minCoord = 3;
                maxCoord = 17;
                axisDirection = Math.random() < 0.5 ? 'vertical' : 'horizontal';
            }
            
            let tempVertices = [];
            
            if (isSlantedAxis) {
                const axisMidPoint = { x: HALF_COUNT, y: HALF_COUNT };
                let axisPoints = [];
                const axisLength = getRandomInt(3, 7);
                
                const p1 = {x: axisMidPoint.x - axisLength, y: axisMidPoint.y - axisLength};
                const p2 = {x: axisMidPoint.x + axisLength, y: axisMidPoint.y + axisLength};
                
                axisPoints.push(p1);
                axisPoints.push(p2);
                
                tempVertices.push(axisPoints[0]);

                for (let i = 0; i < nVertices - 2; i++) {
                    let newV;
                    let success = false;
                    let attemptCount = 0;
                    while (!success && attemptCount < MAX_ATTEMPTS_PER_POINT) {
                        let x = getRandomInt(minCoord, maxCoord);
                        let y = getRandomInt(minCoord, x - 1);
                        
                        newV = { x: x, y: y };

                        let isValid = true;
                        if (tempVertices.length >= 2) {
                            if(isTooSharpAngle(tempVertices[tempVertices.length-2], tempVertices[tempVertices.length-1], newV)) {
                                isValid = false;
                            }
                        }
                        if (tempVertices.length > 0) {
                            let symV = calculateSymmetricPoint(newV, 'line', true);
                            if (isTooSharpAngle(tempVertices[tempVertices.length - 1], newV, symV)) {
                                isValid = false;
                            }
                        }
                        
                        if (
                            isValid &&
                            !isTooClose(newV, tempVertices) &&
                            !isProblemTooLinear(tempVertices, newV)
                        ) {
                            tempVertices.push(newV);
                            success = true;
                        }
                        attemptCount++;
                    }
                }
                tempVertices.push(axisPoints[1]);
                
                let allVertices = [...tempVertices];
                
                if (allVertices.length < 3) return null;
                
                const lastV = allVertices[allVertices.length - 1];
                const secondLastV = allVertices[allVertices.length - 2];
                const firstV = allVertices[0];

                if (isTooLinear(secondLastV, lastV, firstV) || isTooSharpAngle(secondLastV, lastV, firstV)) {
                    return null;
                }

                let allVerticesSorted = sortSlantedAxisVertices(allVertices);
                
                let isPathValid = true;
                if (allVerticesSorted.length >= 3) {
                    for (let i = 0; i < allVerticesSorted.length - 2; i++) {
                        if (isTooLinear(allVerticesSorted[i], allVerticesSorted[i+1], allVerticesSorted[i+2])) {
                            isPathValid = false;
                            break;
                        }
                    }
                }
                if (!isPathValid) return null;
                
                const allLines = createSequentialLines(allVerticesSorted, false);

                const initialLines = allLines.filter(line => {
                    const midPoint = {x: (line.p1.x + line.p2.x)/2, y: (line.p1.y + line.p2.y)/2};
                    return midPoint.y < midPoint.x;
                });
                
                let initialVertices = initialLines.reduce((acc, line) => {
                    if (!acc.some(v => isSamePoint(v, line.p1))) acc.push(line.p1);
                    if (!acc.some(v => isSamePoint(v, line.p2))) acc.push(line.p2);
                    return acc;
                }, []);
                
                const axisPointsInInitial = initialVertices.filter(v => v.x === v.y);
                if(axisPointsInInitial.length < 2) {
                    return null;
                }
                
                allVertices = allVerticesSorted;

                return {
                    type: 'line',
                    isSlantedAxis: true,
                    axisDirection: 'slanted',
                    initialVertices: initialVertices,
                    initialLines: initialLines,
                    allVertices: allVertices,
                    allLines: allLines
                };

            } else {
                
                if (axisDirection === 'vertical') {
                    const pointCount = nVertices;
                    let nonAxisPoints = [];

                    const axisPoint1 = { x: HALF_COUNT, y: getRandomInt(minCoord, HALF_COUNT - 2) };
                    const axisPoint2 = { x: HALF_COUNT, y: getRandomInt(HALF_COUNT + 2, maxCoord) };
                    
                    for (let i = 0; i < pointCount - 2; i++) {
                        let newV;
                        let success = false;
                        let attemptCount = 0;
                        while (!success && attemptCount < MAX_ATTEMPTS_PER_POINT) {
                            let x = getRandomInt(minCoord, HALF_COUNT - 1);
                            let y = getRandomInt(axisPoint1.y, axisPoint2.y);
                            newV = { x: x, y: y };

                            let isValid = !isTooClose(newV, [...nonAxisPoints, axisPoint1, axisPoint2]);
                            
                            if (nonAxisPoints.length > 0) {
                                let lastPoint = nonAxisPoints[nonAxisPoints.length - 1];
                                if (isTooWeakSlope(lastPoint, newV)) {
                                    isValid = false;
                                }
                            }
                            if (isValid) {
                                nonAxisPoints.push(newV);
                                success = true;
                            }
                            attemptCount++;
                        }
                    }
                    nonAxisPoints.sort((a, b) => a.y - b.y);

                    let initialVertices = [axisPoint1, ...nonAxisPoints, axisPoint2];
                    
                    if (initialVertices.length < 2) return null;
                    
                    let isPathValid = true;
                    if (initialVertices.length >= 3) {
                        for (let i = 0; i < initialVertices.length - 2; i++) {
                            if (isTooLinear(initialVertices[i], initialVertices[i+1], initialVertices[i+2])) {
                                isPathValid = false;
                                break;
                            }
                        }
                    }
                    if (!isPathValid) return null;

                    let allVertices = initialVertices.concat(initialVertices.map(v => calculateSymmetricPoint(v, 'line', false, axisDirection)).reverse());
                    allVertices = allVertices.filter((v, i, self) => i === self.findIndex((t) => isSamePoint(t, v)));
                    
                    let initialLines = createSequentialLines(initialVertices, false);
                    
                    return {
                        type: 'line',
                        isSlantedAxis: false,
                        axisDirection: axisDirection,
                        initialVertices: initialVertices,
                        initialLines: initialLines,
                        allVertices: allVertices,
                        allLines: createSequentialLines(allVertices, true)
                    };

                } else { // horizontal
                    const pointCount = nVertices;
                    let nonAxisPoints = [];
                    
                    const axisPoint1 = { x: getRandomInt(minCoord, HALF_COUNT - 2), y: HALF_COUNT };
                    const axisPoint2 = { x: getRandomInt(HALF_COUNT + 2, maxCoord), y: HALF_COUNT };

                    for (let i = 0; i < pointCount - 2; i++) {
                        let newV;
                        let success = false;
                        let attemptCount = 0;
                        while (!success && attemptCount < MAX_ATTEMPTS_PER_POINT) {
                            let x = getRandomInt(axisPoint1.x, axisPoint2.x);
                            let y = getRandomInt(minCoord, HALF_COUNT - 1);
                            newV = { x: x, y: y };
                            
                            let isValid = !isTooClose(newV, [...nonAxisPoints, axisPoint1, axisPoint2]);
                            if (nonAxisPoints.length > 0) {
                                let lastPoint = nonAxisPoints[nonAxisPoints.length - 1];
                                if (isTooWeakSlope(lastPoint, newV)) {
                                    isValid = false;
                                }
                            }
                            
                            if (isValid) {
                                nonAxisPoints.push(newV);
                                success = true;
                            }
                            attemptCount++;
                        }
                    }
                    nonAxisPoints.sort((a, b) => a.x - b.x);

                    let initialVertices = [axisPoint1, ...nonAxisPoints, axisPoint2];
                    
                    if (initialVertices.length < 2) return null;
                    
                    let isPathValid = true;
                    if (initialVertices.length >= 3) {
                        for (let i = 0; i < initialVertices.length - 2; i++) {
                            if (isTooLinear(initialVertices[i], initialVertices[i+1], initialVertices[i+2])) {
                                isPathValid = false;
                                break;
                            }
                        }
                    }
                    if (!isPathValid) return null;
                    
                    let allVertices = initialVertices.concat(initialVertices.map(v => calculateSymmetricPoint(v, 'line', false, axisDirection)).reverse());
                    allVertices = allVertices.filter((v, i, self) => i === self.findIndex((t) => isSamePoint(t, v)));

                    let initialLines = createSequentialLines(initialVertices, false);

                    return {
                        type: 'line',
                        isSlantedAxis: false,
                        axisDirection: axisDirection,
                        initialVertices: initialVertices,
                        initialLines: initialLines,
                        allVertices: allVertices,
                        allLines: createSequentialLines(allVertices, true)
                    };
                }
            }

} else if (type === 'point') {
    // *** ì´ ë¶€ë¶„ì„ ìˆ˜ì •í–ˆìŠµë‹ˆë‹¤! ***
    const numPoints = (selectedDifficulty == 1) ? 4 : getRandomInt(5, 6);
    let initialPoints = [];
    const MAX_POINT_GEN_ATTEMPTS = 50;
            let currentAttempts = 0;

            const isHorizontalAxis = Math.random() < 0.5;
            let lineStart, lineEnd;

            if(isHorizontalAxis) {
                const y = CENTER_POINT.y;
                const halfLength = getRandomInt(3, 7);
                lineStart = {x: CENTER_POINT.x - halfLength, y: y};
                lineEnd = {x: CENTER_POINT.x + halfLength, y: y};
            } else {
                const x = CENTER_POINT.x;
                const halfLength = getRandomInt(3, 7);
                lineStart = {x: x, y: CENTER_POINT.y - halfLength};
                lineEnd = {x: x, y: CENTER_POINT.y + halfLength};
            }
            initialPoints.push(lineStart);
            
            const numInnerPoints = numPoints - 2;
            let halfVertices = [];
            for(let i = 0; i < numInnerPoints; i++) {
                let newV;
                let success = false;
                let attemptCount = 0;
                while(!success && attemptCount < MAX_ATTEMPTS_PER_POINT) {
                    let x, y;
                    if(isHorizontalAxis) {
                        x = getRandomInt(MIN_COORD, MAX_COORD);
                        y = getRandomInt(MIN_COORD, CENTER_POINT.y - 1);
                    } else {
                        x = getRandomInt(MIN_COORD, CENTER_POINT.x - 1);
                        y = getRandomInt(MIN_COORD, MAX_COORD);
                    }
                    newV = {x: x, y: y};
                    
                    if(!isTooClose(newV, [...initialPoints, ...halfVertices])) {
                        halfVertices.push(newV);
                        success = true;
                    }
                    attemptCount++;
                }
                if(!success) return null;
            }
            halfVertices.sort((a, b) => {
                const angleA = Math.atan2(a.y - CENTER_POINT.y, a.x - CENTER_POINT.x);
                const angleB = Math.atan2(b.y - CENTER_POINT.y, b.x - CENTER_POINT.x);
                return angleA - angleB;
            });
            initialPoints = initialPoints.concat(halfVertices);
            initialPoints.push(lineEnd);

            let allVertices = [];
            let processed = new Set();
            initialPoints.forEach(p => {
                const key = `${p.x},${p.y}`;
                if (!processed.has(key)) {
                    allVertices.push(p);
                    processed.add(key);
                    const symV = calculateSymmetricPoint(p, 'point');
                    const symKey = `${symV.x},${symV.y}`;
                    if (!processed.has(symKey)) {
                        allVertices.push(symV);
                        processed.add(symKey);
                    }
                }
            });

            allVertices = findPointSymmetricBoundary(allVertices);

            let isProblemValid = true;
            if (allVertices.length >= 3) {
                for (let i = 0; i < allVertices.length; i++) {
                    const len = allVertices.length;
                    const p1 = allVertices[(i - 1 + len) % len];
                    const p2 = allVertices[i];
                    const p3 = allVertices[(i + 1) % len];
                    
                    if (isTooLinear(p1, p2, p3) || isTooSharpAngle(p1, p2, p3)) {
                        isProblemValid = false;
                        break;
                    }
                }
            }
            if(!isProblemValid) return null;
            
            const allLines = createSequentialLines(allVertices, true);

            const initialLines = [];
            const initialSet = new Set(initialPoints.map(p => `${p.x},${p.y}`));
            allLines.forEach(line => {
                if(initialSet.has(`${line.p1.x},${line.p1.y}`) && initialSet.has(`${line.p2.x},${line.p2.y}`)) {
                    initialLines.push(line);
                }
            });
            
            return {
                type: 'point',
                initialVertices: initialPoints,
                initialLines: initialLines,
                allVertices: allVertices,
                allLines: allLines
            };
        }
        return null;
    }

    // 1. ì„¤ì • ë° ì‹œì‘
    function initializeSetupListeners() {
        document.querySelectorAll('#type-select button').forEach(button => {
            button.addEventListener('click', handleTypeSelect);
        });
        document.querySelectorAll('#difficulty-select button').forEach(button => {
            button.addEventListener('click', handleDifficultySelect);
        });
        document.getElementById('quantity-minus').addEventListener('click', () => changeQuantity(-5));
        document.getElementById('quantity-plus').addEventListener('click', () => changeQuantity(5));
    }

    function handleTypeSelect(event) {
        document.querySelectorAll('#type-select button').forEach(b => b.classList.remove('selected'));
        event.currentTarget.classList.add('selected');
        selectedType = event.currentTarget.getAttribute('data-type');
    }
    
    function handleDifficultySelect(event) {
        document.querySelectorAll('#difficulty-select button').forEach(b => b.classList.remove('selected'));
        event.currentTarget.classList.add('selected');
        selectedDifficulty = event.currentTarget.getAttribute('data-difficulty');
    }

    function changeQuantity(delta) {
        const current = parseInt(document.getElementById('problem-quantity').textContent);
        let newQuantity = current + delta;
        if (newQuantity < 5) newQuantity = 5;
        if (newQuantity > 50) newQuantity = 50;
        document.getElementById('problem-quantity').textContent = newQuantity;
        totalProblems = newQuantity;
    }

    function startQuiz() {
        const problemsToGenerate = totalProblems;
        problemList = [];
        let generatedVertexStrings = new Set();
        let attempt = 0;
        const MAX_ATTEMPTS = problemsToGenerate * 20;

        while (problemList.length < problemsToGenerate && attempt < MAX_ATTEMPTS) {
            let type;
            if (selectedType === 'both') {
                type = Math.random() < 0.5 ? 'line' : 'point';
            } else {
                type = selectedType;
            }
            
            const newProblem = generateRandomProblem(type);
            
            if (newProblem && newProblem.initialVertices.length >= 2) {
                const vertexString = JSON.stringify(newProblem.initialVertices.map(v => `${v.x},${v.y}`).sort());
                if (!generatedVertexStrings.has(vertexString)) {
                    problemList.push(newProblem);
                    generatedVertexStrings.add(vertexString);
                }
            }
            attempt++;
        }
        
        totalProblems = problemList.length;
        
        if (totalProblems === 0) {
            alert('ë¬¸ì œ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ì„¤ì •ìœ¼ë¡œ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.');
            location.reload();
            return;
        }
        
        currentProblem = 0;
        score = { results: [] }; // âœ¨ ìƒˆë¡œìš´ ì ìˆ˜ ê°ì²´ë¡œ ì´ˆê¸°í™”
        currentProblemAttempts = 0; // âœ¨ ì‹œë„ íšŸìˆ˜ ì´ˆê¸°í™”
        hasSubmittedScore = false; // ìƒˆ ê²Œì„ ì‹œì‘ ì‹œ ë“±ë¡ í”Œë˜ê·¸ ì´ˆê¸°í™”
        
        document.getElementById('setup-page').style.display = 'none';
        document.getElementById('problem-page').style.display = 'block';
        
        loadProblem();
    }

    function loadProblem() {
        if (currentProblem >= totalProblems) {
            showFinalResult();
            return;
        }

        const currentP = problemList[currentProblem];
        const pType = currentP.type === 'line' ? 'ì„ ëŒ€ì¹­' : 'ì ëŒ€ì¹­';
        
        let problemNumText = `${currentProblem + 1}ë²ˆì§¸ ë¬¸ì œ (${pType})`;
        const pTypeText = currentP.type === 'line' ? 'ì„ ëŒ€ì¹­ë„í˜•' : 'ì ëŒ€ì¹­ë„í˜•';
        let instructionText = `ì•„ë˜ ë„í˜•ì€ ${pTypeText}ì…ë‹ˆë‹¤. ë‚˜ë¨¸ì§€ ë¶€ë¶„ì„ ì™„ì„±í•´ ì£¼ì„¸ìš”.`;

        if (window.innerWidth < 480) {
            problemNumText = `${currentProblem + 1}ë²ˆì§¸ ë¬¸ì œ<br>(${pType})`;
            instructionText = `ì•„ë˜ ë„í˜•ì€ ${pTypeText}ì…ë‹ˆë‹¤.<br>ë‚˜ë¨¸ì§€ ë¶€ë¶„ì„ ì™„ì„±í•´ ì£¼ì„¸ìš”.`;
        }
        document.getElementById('problem-number').innerHTML = problemNumText;
        document.getElementById('problem-instruction').innerHTML = instructionText;
        
        const checkBtn = document.getElementById('check-answer-btn');
        const nextBtn = document.getElementById('next-problem-btn');
        checkBtn.style.display = 'block';
        nextBtn.style.display = 'none';

        closePopup();
        
        currentProblemAttempts = 0;

        problemVertices = currentP.initialVertices;
        problemLines = currentP.initialLines;
        userVertices = [];
        userLines = [];
        tempLineStart = null;
        hoveredLine = null;
        
        setCanvasMode('vertex');
        
        clearCanvas(false);
    }

    function clearCanvas(clearUserDrawing) {
        if (clearUserDrawing) {
            userVertices = [];
            userLines = [];
            tempLineStart = null;
            hoveredLine = null;
        }
        document.querySelectorAll('.user-dot').forEach(dot => dot.remove());
        
        redrawCanvas();
        setCanvasMode('vertex');
        closePopup();
        
        const checkBtn = document.getElementById('check-answer-btn');
        const nextBtn = document.getElementById('next-problem-btn');
        checkBtn.style.display = 'block';
        nextBtn.style.display = 'none';
    }
    
    // 2. ìº”ë²„ìŠ¤ ê·¸ë¦¬ê¸° ë° ëª¨ë“œ ì œì–´
    function renderProblemVertices() {
        document.querySelectorAll('.problem-dot').forEach(dot => dot.remove());
        problemVertices.forEach((v) => {
            const dot = document.createElement('div');
            dot.className = 'problem-dot';
            dot.style.left = `${(v.x / GRID_COUNT) * 100}%`;
            dot.style.top = `${(v.y / GRID_COUNT) * 100}%`;
            canvasWrapper.appendChild(dot);
        });
    }

    function drawGrid() {
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 0.5;
        
        ctx.setLineDash([1, 4]);
        
        for (let x = 0; x <= canvas.width; x += GRID_SIZE) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
        }
        for (let y = 0; y <= canvas.height; y += GRID_SIZE) {
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
        }
        
        ctx.setLineDash([]);

        if (problemList.length > currentProblem) {
            const currentP = problemList[currentProblem];
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 2;
            if (currentP.type === 'line') {
                if (currentP.isSlantedAxis) {
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(canvas.width, canvas.height);
                    ctx.stroke();
                } else if (currentP.axisDirection === 'vertical') {
                    const centerX = canvas.width / 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX, 0);
                    ctx.lineTo(centerX, canvas.height);
                    ctx.stroke();
                } else if (currentP.axisDirection === 'horizontal') {
                    const centerY = canvas.height / 2;
                    ctx.beginPath();
                    ctx.moveTo(0, centerY);
                    ctx.lineTo(canvas.width, centerY);
                    ctx.stroke();
                }
            } else if (currentP.type === 'point') {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
                ctx.fillStyle = '#ff0000';
                ctx.fill();
            }
        }
    }

    function drawLines(lines, color) {
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        lines.forEach(line => {
            ctx.beginPath();
            ctx.moveTo(line.p1.x * GRID_SIZE, line.p1.y * GRID_SIZE);
            ctx.lineTo(line.p2.x * GRID_SIZE, line.p2.y * GRID_SIZE);
            ctx.stroke();
        });
    }

    function redrawCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();

        drawLines(problemLines, '#007bff');
        drawLines(userLines, '#28a745');
        
        if (hoveredLine) {
            ctx.save();
            ctx.strokeStyle = 'rgba(234, 153, 153, 0.5)';
            ctx.lineWidth = 8;
            ctx.shadowColor = 'rgba(234, 153, 153, 0.7)';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(hoveredLine.p1.x * GRID_SIZE, hoveredLine.p1.y * GRID_SIZE);
            ctx.lineTo(hoveredLine.p2.x * GRID_SIZE, hoveredLine.p2.y * GRID_SIZE);
            ctx.stroke();
            ctx.restore();
        }

        renderProblemVertices();

        if (canvasMode === 'line') {
            renderPointsForLineMode();
        } else {
             renderUserVertices();
        }
    }

    function renderPointsForLineMode() {
        document.querySelectorAll('.user-dot, .line-dot, .selected-line-dot').forEach(dot => dot.remove());

        const allPoints = [...problemVertices, ...userVertices].filter((v, i, self) => i === self.findIndex(t => isSamePoint(t, v)));
        
        allPoints.forEach((v) => {
            const dot = document.createElement('div');
            dot.className = (tempLineStart && isSamePoint(v, tempLineStart)) ? 'selected-line-dot' : 'line-dot';
            dot.style.left = `${(v.x / GRID_COUNT) * 100}%`;
            dot.style.top = `${(v.y / GRID_COUNT) * 100}%`;
            canvasWrapper.appendChild(dot);
        });
    }

    function renderUserVertices() {
        document.querySelectorAll('.user-dot, .line-dot, .selected-line-dot').forEach(dot => dot.remove());

        userVertices.forEach((v) => {
            const dot = document.createElement('div');
            dot.className = 'user-dot';
            dot.style.left = `${(v.x / GRID_COUNT) * 100}%`;
            dot.style.top = `${(v.y / GRID_COUNT) * 100}%`;
            canvasWrapper.appendChild(dot);
        });
    }

    function isVertexOnProblemBoundary(v) {
        return problemVertices.some(pv => isSamePoint(pv, v));
    }
    
    function showPopup(mainMessage, detailMessage, isCorrect) {
        const popupOverlay = document.getElementById('result-popup-overlay');
        const popupMainMessage = document.getElementById('popup-main-message');
        const popupDetailMessage = document.getElementById('popup-detail-message');
        const popupNextBtn = document.getElementById('popup-next-btn');

        if (isCorrect) {
            popupMainMessage.innerHTML = mainMessage;
            popupMainMessage.className = 'correct';
            popupDetailMessage.style.display = 'none';
            popupNextBtn.style.display = 'block';
        } else {
            popupMainMessage.innerHTML = `${mainMessage}<br><span style="font-size: 80%;">${detailMessage}</span>`;
            popupMainMessage.className = 'incorrect';
            popupDetailMessage.style.display = 'none';
            popupNextBtn.style.display = 'none';
        }
        
        popupOverlay.style.display = 'flex';
    }

    function closePopup() {
        document.getElementById('result-popup-overlay').style.display = 'none';
    }

    function checkAnswer() {
        const currentP = problemList[currentProblem];
        const problemType = currentP.type;
        
        let verticesAreCorrect = checkVerticesSymmetry(problemType);
        let isLinesCorrect = false;

        if (verticesAreCorrect) {
            if (problemType === 'line') {
                isLinesCorrect = checkLineSymmetryLines(currentP);
            } else if (problemType === 'point') {
                isLinesCorrect = checkPointSymmetryLines(currentP);
            }
        }
        
        if (verticesAreCorrect && isLinesCorrect) {
            showPopup('ì •ë‹µì…ë‹ˆë‹¤ğŸ‰', '', true);
            
        // 'ëª‡ ë²ˆ í‹€ë ¸ëŠ”ì§€(currentProblemAttempts)'ë¥¼ ê²°ê³¼ ë°°ì—´ì— ì¶”ê°€í•©ë‹ˆë‹¤.
        score.results.push(currentProblemAttempts); 
        saveGameState();
            
            document.getElementById('check-answer-btn').style.display = 'none';
            document.getElementById('next-problem-btn').style.display = 'block';

        } else {
            let detailMessage;
            
            if (!verticesAreCorrect) {
                detailMessage = 'ê¼­ì§“ì ì˜ ìœ„ì¹˜ë‚˜ ê°œìˆ˜ê°€ ì˜ëª»ë˜ì—ˆì–´ìš”.';
            } else if (!isLinesCorrect) {
                detailMessage = 'ë„í˜•ì´ ëŒ€ì¹­ì„ ì´ë£¨ì§€ ì•Šê±°ë‚˜ ë¹ ëœ¨ë¦° ì„ ë¶„ì´ ìˆì–´ìš”.';
            } else {
                detailMessage = 'ê¼­ì§“ì ì´ë‚˜ ì„ ë¶„ ì—°ê²°ì— ì˜¤ë¥˜ê°€ ìˆì–´ ëŒ€ì¹­ë„í˜•ì´ ì™„ì„±ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.';
            }

            showPopup('ë‹¤ì‹œ ìƒê°í•´ ë³¼ê¹Œìš”?', detailMessage, false);
            currentProblemAttempts++;
            
            document.getElementById('check-answer-btn').style.display = 'block';
            document.getElementById('next-problem-btn').style.display = 'none';
        }
    }

    function checkVerticesSymmetry(problemType) {
        const currentP = problemList[currentProblem];
        const isSlantedAxis = (currentP.type === 'line' && currentP.isSlantedAxis);
        
        const allProblemAndUserVerticesSet = new Map();
        [...problemVertices, ...userVertices].forEach(v => {
            const key = `${Math.round(v.x)},${Math.round(v.y)}`;
            if (!allProblemAndUserVerticesSet.has(key)) {
                allProblemAndUserVerticesSet.set(key, { x: Math.round(v.x), y: Math.round(v.y) });
            }
        });
        const finalVertices = Array.from(allProblemAndUserVerticesSet.values());
        
        const numVertices = finalVertices.length;
        
        if (problemType === 'line') {
            const axisDirection = currentP.axisDirection;
            let boundaryVerticesCount;

            if (isSlantedAxis) {
                boundaryVerticesCount = finalVertices.filter(v => v.x === v.y).length;
            } else if (axisDirection === 'vertical') {
                boundaryVerticesCount = finalVertices.filter(v => v.x === HALF_COUNT).length;
            } else if (axisDirection === 'horizontal') {
                boundaryVerticesCount = finalVertices.filter(v => v.y === HALF_COUNT).length;
            }
            
            const nonBoundaryCount = numVertices - boundaryVerticesCount;

            if (nonBoundaryCount % 2 !== 0) {
                return false;
            }
        }
        
        let symmetricPairs = new Map();
        for (const v of finalVertices) {
            const key = `${v.x},${v.y}`;
            if (symmetricPairs.has(key)) continue;

            const symmetricV = calculateSymmetricPoint(v, problemType, isSlantedAxis, currentP.axisDirection);
            
            if (isSamePoint(v, symmetricV)) {
                symmetricPairs.set(key, true);
                continue;
            }

            const symmetricExists = finalVertices.some(av => isSamePoint(av, symmetricV));

            if (!symmetricExists) return false;
            
            symmetricPairs.set(key, true);
            symmetricPairs.set(`${symmetricV.x},${symmetricV.y}`, true);
        }
        return true;
    }
    
    function checkLineSymmetryLines(currentP) {
        const correctSymmetricLines = currentP.initialLines.map(line => ({
            p1: calculateSymmetricPoint(line.p1, 'line', currentP.isSlantedAxis, currentP.axisDirection),
            p2: calculateSymmetricPoint(line.p2, 'line', currentP.isSlantedAxis, currentP.axisDirection)
        }));
        
        if (userLines.length !== correctSymmetricLines.length) {
            return false;
        }

        for (const userLine of userLines) {
            const match = correctSymmetricLines.some(correctLine => isSameLine(userLine, correctLine));
            if (!match) {
                return false;
            }
        }
        
        return true;
    }
    
function checkPointSymmetryLines(currentP) {
    // 1. ë¬¸ì œì— ì›ë˜ ìˆë˜ ì„ ë“¤ê³¼ ì‚¬ìš©ìê°€ ê·¸ë¦° ì„ ë“¤ì„ ëª¨ë‘ í•©ì¹©ë‹ˆë‹¤.
    const allDrawnLines = [...problemLines, ...userLines];

    // 2. ì™„ì„±ëœ ë„í˜•ì˜ ì •ë‹µ ì„ ë“¤ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.
    const correctLines = currentP.allLines;

    // 3. ì„ ì˜ ê°œìˆ˜ê°€ ì •ë‹µê³¼ ë‹¤ë¥´ë©´ ì¦‰ì‹œ ì˜¤ë‹µ ì²˜ë¦¬í•©ë‹ˆë‹¤.
    if (allDrawnLines.length !== correctLines.length) {
        return false;
    }

    // 4. ì‚¬ìš©ìê°€ ê·¸ë¦° ëª¨ë“  ì„ ì´ ì •ë‹µ ì„  ëª©ë¡ì— í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
    const correctLinesCopy = [...correctLines]; // ì •ë‹µ ëª©ë¡ ë³µì‚¬ë³¸ ìƒì„±

    for (const drawnLine of allDrawnLines) {
        const matchIndex = correctLinesCopy.findIndex(correctLine => isSameLine(drawnLine, correctLine));

        if (matchIndex === -1) {
            // ì‚¬ìš©ìê°€ ê·¸ë¦° ì„  ì¤‘ì— ì •ë‹µì— ì—†ëŠ” ì„ ì´ ìˆë‹¤ë©´ ì˜¤ë‹µì…ë‹ˆë‹¤.
            return false;
        }
        // í™•ì¸ëœ ì •ë‹µ ì„ ì€ ë³µì‚¬ë³¸ì—ì„œ ì œê±°í•©ë‹ˆë‹¤.
        correctLinesCopy.splice(matchIndex, 1);
    }

    // 5. ëª¨ë“  ê²€ì‚¬ë¥¼ í†µê³¼í•˜ê³  ë³µì‚¬ë³¸ì— ë‚¨ì€ ì„ ì´ ì—†ìœ¼ë©´ ì •ë‹µì…ë‹ˆë‹¤.
    return correctLinesCopy.length === 0;
}
    
    function findClosestValidLinePoint(v) {
        const allTargetVertices = [
            ...problemVertices,
            ...userVertices
        ];
        
        if (problemList.length > currentProblem && problemList[currentProblem].type === 'point') {
            allTargetVertices.push(CENTER_POINT);
        }

        let closestPoint = null;
        let minDistSq = Infinity;

        for (const p of allTargetVertices) {
            const dist = distSq(v, p);
            if (dist < minDistSq) {
                minDistSq = dist;
                closestPoint = p;
            }
        }
        return closestPoint;
    }
    
    function setCanvasMode(mode) {
        canvasMode = mode;
        const vertexBtn = document.getElementById('mode-vertex');
        const lineBtn = document.getElementById('mode-line');

        vertexBtn.classList.remove('mode-btn-active');
        lineBtn.classList.remove('mode-btn-active');
        
        const canStartLineDrawing = userVertices.length >= 1 || problemVertices.length > 1;

        if (mode === 'vertex') {
            vertexBtn.classList.add('mode-btn-active');
            tempLineStart = null;
        } else { // 'line' mode
            lineBtn.classList.add('mode-btn-active');
            vertexBtn.disabled = false;
        }
        
        document.getElementById('mode-line').disabled = !canStartLineDrawing;
        redrawCanvas();
    }
    
    function renderUserVertices() {
        document.querySelectorAll('.user-dot, .line-dot, .selected-line-dot').forEach(dot => dot.remove());

        userVertices.forEach((v) => {
            const dot = document.createElement('div');
            dot.className = 'user-dot';
            dot.style.left = `${(v.x / GRID_COUNT) * 100}%`;
            dot.style.top = `${(v.y / GRID_COUNT) * 100}%`;
            canvasWrapper.appendChild(dot);
        });
    }

    // --- showFinalResult í•¨ìˆ˜ (ì „ì²´ êµì²´) ---
function showFinalResult() {
    clearGameState();
    document.getElementById('problem-page').style.display = 'none';
    document.getElementById('final-result-page').style.display = 'block';

    let totalWeightedScore = 0; // ê°€ì¤‘ì¹˜ê°€ ì ìš©ëœ ì ìˆ˜ì˜ ì´í•©
    let correctCount = 0; // í•œ ë²ˆì— ë§ì¶˜ ë¬¸ì œ ìˆ˜
    let retriedCount = 0; // ì¬ë„ì „í•´ì„œ ë§ì¶˜ ë¬¸ì œ ìˆ˜

    // ìƒì„¸ ê¸°ë¡ì´ ë‹´ê¸´ score.results ë°°ì—´ì„ í•˜ë‚˜ì”© í™•ì¸í•˜ë©° ê³„ì‚°í•©ë‹ˆë‹¤.
    score.results.forEach(attempts => {
        if (attempts === 0) { // 0ë²ˆ ì‹¤íŒ¨ = í•œ ë²ˆì— ë§ì¶¤
            totalWeightedScore += 1.0;
            correctCount++;
        } else if (attempts === 1) { // 1ë²ˆ ì‹¤íŒ¨ = í•œ ë²ˆ ì¬ë„ì „
            totalWeightedScore += 0.8;
            retriedCount++;
        } else if (attempts === 2) { // 2ë²ˆ ì‹¤íŒ¨ = ë‘ ë²ˆ ì¬ë„ì „
            totalWeightedScore += 0.6;
            retriedCount++;
        } else if (attempts === 3) { // 3ë²ˆ ì‹¤íŒ¨ = ì„¸ ë²ˆ ì¬ë„ì „
            totalWeightedScore += 0.4;
            retriedCount++;
        } else { // 4ë²ˆ ì´ìƒ ì‹¤íŒ¨
            // ì ìˆ˜ëŠ” 0ì ì´ì§€ë§Œ, ì¬ë„ì „ ì„±ê³µ íšŸìˆ˜ì—ëŠ” í¬í•¨ë©ë‹ˆë‹¤.
            retriedCount++;
        }
    });

    const total = totalProblems;
    // ìƒˆë¡œìš´ ì •í™•ë„ ê³„ì‚° ë°©ì‹
    const accuracy = total > 0 ? parseFloat(((totalWeightedScore / total) * 100).toFixed(1)) : 0;
    finalAccuracyValue = accuracy;

    // ìµœì¢… ì ìˆ˜ ê³„ì‚° ë¡œì§ì€ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ë˜, ìƒˆë¡œ ê³„ì‚°ëœ accuracyë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
    const difficultyMultiplier = (selectedDifficulty == 2) ? 1.5 : 1;
    let typeMultiplier = 1.0;
    if (selectedType === 'point') {
        typeMultiplier = 1.1;
    } else if (selectedType === 'both') {
        typeMultiplier = 1.05;
    }
    const finalScore = Math.round((total * accuracy) * difficultyMultiplier * typeMultiplier);

    // ê³„ì‚°ëœ ê²°ê³¼ë¥¼ í™”ë©´ì— í‘œì‹œí•©ë‹ˆë‹¤.
    document.getElementById('correct-count').textContent = correctCount;
    document.getElementById('retried-count').textContent = retriedCount;
    document.getElementById('final-accuracy').textContent = `${accuracy}%`;
    document.getElementById('final-score').textContent = finalScore;
}

    function handleCanvasMouseMove(event) {
        if (document.getElementById('check-answer-btn').style.display === 'none') {
            if (hoveredLine) {
                hoveredLine = null;
                canvas.style.cursor = 'default';
                redrawCanvas();
            }
            return;
        }
        
        const rect = canvas.getBoundingClientRect();
        const mouseXRatio = (event.clientX - rect.left) / rect.width;
        const mouseYRatio = (event.clientY - rect.top) / rect.height;
        const canvasX = mouseXRatio * canvas.width;
        const canvasY = mouseYRatio * canvas.height;
        const mousePoint = { x: canvasX / GRID_SIZE, y: canvasY / GRID_SIZE };

        let bestLine = null;
        let minDistSq = 0.25;

        for (const line of userLines) {
            const p1 = line.p1;
            const p2 = line.p2;
            const lineLengthSq = distSq(p1, p2);

            if (lineLengthSq === 0) continue;

            let t = ((mousePoint.x - p1.x) * (p2.x - p1.x) + (mousePoint.y - p1.y) * (p2.y - p1.y)) / lineLengthSq;
            
            if (t > 0.2 && t < 0.8) {
                const closestPointOnLine = {
                    x: p1.x + t * (p2.x - p1.x),
                    y: p1.y + t * (p2.y - p1.y)
                };
                const distanceSq = distSq(mousePoint, closestPointOnLine);
                if (distanceSq < minDistSq) {
                    minDistSq = distanceSq;
                    bestLine = line;
                }
            }
        }
        
        if (!isSameLine(hoveredLine, bestLine)) {
            hoveredLine = bestLine;
            redrawCanvas();
        }

        if (hoveredLine) {
            canvas.style.cursor = 'pointer';
        } else if (canvasMode === 'line') {
            canvas.style.cursor = 'pointer';
        } else {
            canvas.style.cursor = 'crosshair';
        }
    }

    function showQrPopup() {
        document.getElementById('qr-popup-overlay').style.display = 'flex';
    }

    function closeQrPopup() {
        document.getElementById('qr-popup-overlay').style.display = 'none';
    }
    
    function showHofPopup() {
        const tableBody = document.querySelector('#hof-table tbody');
        const messageEl = document.getElementById('hof-message');
        const inputGroup = document.querySelector('.hof-input-group');

        if (hasSubmittedScore) {
            inputGroup.style.display = 'none';
            messageEl.textContent = 'ì´ë²ˆ í•™ìŠµ ê¸°ë¡ì€ ì´ë¯¸ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤.';
            messageEl.style.color = 'blue';
        } else {
            inputGroup.style.display = 'block';
            messageEl.textContent = '';
            document.getElementById('hof-initial').value = '';
            document.getElementById('hof-submit-btn').disabled = false;
        }
        
        tableBody.innerHTML = '<tr><td colspan="3">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</td></tr>';
        document.getElementById('hof-popup-overlay').style.display = 'flex';

        fetch(webAppUrl)
            .then(response => response.json())
            .then(data => {
                tableBody.innerHTML = ''; 
                if (data.length === 0) {
                    tableBody.innerHTML = '<tr><td colspan="3">ì•„ì§ ë“±ë¡ëœ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</td></tr>';
                } else {
                    data.forEach(item => {
                        let initialStyle = '';
                        if (item.rank === 1) initialStyle = 'style="color: #d4af37; font-weight: bold; text-shadow: 0 0 4px #fff, 0 0 6px #ff0;"'; 
                        if (item.rank === 2) initialStyle = 'style="color: #c0c0c0; font-weight: bold; text-shadow: 0 0 3px #fff;"';
                        if (item.rank === 3) initialStyle = 'style="color: #cd7f32; font-weight: bold; text-shadow: 0 0 3px #fff;"'; 
                        
                        const row = `<tr>
                            <td>${item.rank}</td>
                            <td ${initialStyle}>${item.initial} ${item.rank === 1 ? 'ğŸ¥‡' : item.rank === 2 ? 'ğŸ¥ˆ' : item.rank === 3 ? 'ğŸ¥‰' : ''}</td>
                            <td>${item.score}</td>
                        </tr>`;
                        tableBody.innerHTML += row;
                    });
                }
            })
            .catch(error => {
                tableBody.innerHTML = '<tr><td colspan="3">ê¸°ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.</td></tr>';
                console.error('Error fetching leaderboard:', error);
            });
    }

    function closeHofPopup() {
        document.getElementById('hof-popup-overlay').style.display = 'none';
    }

    // ì§„í–‰ìƒí™© ì €ì¥

    function saveGameState() {
    // ì €ì¥í•  ëª¨ë“  ë°ì´í„°ë¥¼ í•˜ë‚˜ì˜ ê°ì²´ì— ë‹´ìŠµë‹ˆë‹¤.
    const gameState = {
        problemList: problemList,
        currentProblem: currentProblem,
        score: score,
        userVertices: userVertices,
        userLines: userLines,
        canvasMode: canvasMode,
        // ì„¤ì •ê°’ë„ í•„ìš”í•˜ë‹¤ë©´ ì¶”ê°€í•©ë‹ˆë‹¤.
        selectedType: selectedType,
        selectedDifficulty: selectedDifficulty,
        totalProblems: totalProblems
    };

    // ê°ì²´ë¥¼ JSON ë¬¸ìì—´ë¡œ ë³€í™˜í•˜ì—¬ localStorageì— ì €ì¥í•©ë‹ˆë‹¤.
    localStorage.setItem('quizState', JSON.stringify(gameState));
    console.log("ê²Œì„ ìƒíƒœê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤."); // í™•ì¸ìš© ë¡œê·¸
}

function loadGameState() {
    const savedStateString = localStorage.getItem('quizState');
    if (!savedStateString) return false;

    const savedState = JSON.parse(savedStateString);

    problemList = savedState.problemList;
    currentProblem = savedState.currentProblem;
    score = savedState.score;
    userVertices = savedState.userVertices || [];
    userLines = savedState.userLines || [];
    selectedType = savedState.selectedType;
    selectedDifficulty = savedState.selectedDifficulty;
    totalProblems = savedState.totalProblems;
    
    return true;
}

function clearGameState() {
    localStorage.removeItem('quizState');
}

// *** ìˆ˜ì •ëœ JavaScript í•¨ìˆ˜ ***

function submitScore() {
    const initialInput = document.getElementById('hof-initial');
    const initial = initialInput.value;
    const submitBtn = document.getElementById('hof-submit-btn');
    const messageEl = document.getElementById('hof-message');

    if (!/^[A-Z]{3}$/.test(initial)) {
        messageEl.textContent = 'ì´ë‹ˆì…œì€ ì˜ì–´ ëŒ€ë¬¸ì 3ê¸€ìë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.';
        messageEl.style.color = 'red';
        return;
    }

    submitBtn.disabled = true;
    messageEl.textContent = 'ë“±ë¡ ì¤‘...';
    messageEl.style.color = '#333';

    const data = {
        initial: initial,
        problems: totalProblems,
        accuracy: finalAccuracyValue,
        difficulty: selectedDifficulty,
        type: selectedType // <-- ì´ ì¤„ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!
    };

    fetch(webAppUrl, {
        method: 'POST',
        cache: 'no-cache',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(data)
    })
    .then(response => response.json())
    .then(result => {
        if (result.result === 'success') {
            hasSubmittedScore = true;
            messageEl.textContent = 'ì„±ê³µì ìœ¼ë¡œ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤!';
            messageEl.style.color = '#4B8134';
            document.querySelector('.hof-input-group').style.display = 'none';
            setTimeout(showHofPopup, 1500);
        } else {
            throw new Error(result.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜');
        }
    })
    .catch(error => {
        messageEl.textContent = 'ë“±ë¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.';
        messageEl.style.color = 'red';
        submitBtn.disabled = false;
        console.error('Error submitting score:', error);
    });
}


window.onload = () => {
    // ==================================================================
    // 1. í˜ì´ì§€ ì‹œì‘ ì‹œ, ì €ì¥ëœ ìƒíƒœë¥¼ ë¶ˆëŸ¬ì˜¤ê±°ë‚˜ ìƒˆë¡œ ì‹œì‘ì„ ê²°ì •í•˜ëŠ” ë¶€ë¶„
    // ==================================================================
    if (loadGameState()) {
        // "ì´ì–´í•˜ê¸°": ì €ì¥ëœ ìƒíƒœ ë¶ˆëŸ¬ì˜¤ê¸° ì„±ê³µ
        console.log("ì €ì¥ëœ ê²Œì„ ìƒíƒœë¥¼ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤.");
        document.getElementById('setup-page').style.display = 'none';
        document.getElementById('problem-page').style.display = 'block';
        loadProblem(); // ì €ì¥ëœ ë¬¸ì œ ë²ˆí˜¸ì— ë§ì¶° í™”ë©´ì„ ë‹¤ì‹œ ê·¸ë¦¼
    } else {
        // "ìƒˆë¡œ ì‹œì‘": ì €ì¥ëœ ìƒíƒœê°€ ì—†ìŒ
        console.log("ìƒˆ ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤.");
        document.getElementById('problem-quantity').textContent = totalProblems;
        document.getElementById('mode-line').disabled = true;
        document.getElementById('setup-page').style.display = 'flex'; // ì„¤ì • í™”ë©´ í‘œì‹œ
    }

    // ==================================================================
    // 2. ëª¨ë“  ë²„íŠ¼ê³¼ ìº”ë²„ìŠ¤ì˜ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë¥¼ ë“±ë¡í•˜ëŠ” ë¶€ë¶„ (í•œ ë²ˆë§Œ ì‹¤í–‰)
    // ==================================================================
    initializeSetupListeners();

    canvas.addEventListener('mousemove', handleCanvasMouseMove);
    canvas.addEventListener('mouseleave', () => {
        if (hoveredLine) {
            hoveredLine = null;
            redrawCanvas();
        }
    });

    canvas.addEventListener('click', (event) => {
        // (ì—¬ê¸°ëŠ” ê¸°ì¡´ canvas í´ë¦­ ì´ë²¤íŠ¸ ì½”ë“œì™€ ì™„ì „íˆ ë™ì¼í•©ë‹ˆë‹¤)
        if (document.getElementById('check-answer-btn').style.display === 'none' && document.getElementById('next-problem-btn').style.display === 'block') return;
        
        if (hoveredLine) {
            userLines = userLines.filter(line => !isSameLine(line, hoveredLine));
            hoveredLine = null;
            handleCanvasMouseMove(event);
            redrawCanvas();
            saveGameState(); // <-- ìƒíƒœ ë³€ê²½ í›„ ì €ì¥!
            return;
        }

        const rect = canvas.getBoundingClientRect();
        const mouseXRatio = (event.clientX - rect.left) / rect.width;
        const mouseYRatio = (event.clientY - rect.top) / rect.height;
        const canvasX = mouseXRatio * canvas.width;
        const canvasY = mouseYRatio * canvas.height;
        
        const gridX = Math.round(canvasX / GRID_SIZE);
        const gridY = Math.round(canvasY / GRID_SIZE);
        if (gridX < 0 || gridX > GRID_COUNT || gridY < 0 || gridY > GRID_COUNT) return;

        const clickedGridPoint = { x: gridX, y: gridY };

        if (canvasMode === 'vertex') {
            if (isVertexOnProblemBoundary(clickedGridPoint)) {
                return;
            }

            const existingIndex = userVertices.findIndex(v => isSamePoint(v, clickedGridPoint));
            if (existingIndex > -1) {
                userVertices.splice(existingIndex, 1);
                userLines = userLines.filter(line =>
                    !(isSamePoint(line.p1, clickedGridPoint) || isSamePoint(line.p2, clickedGridPoint))
                );
            } else {
                userVertices.push(clickedGridPoint);
            }
            redrawCanvas();

        } else if (canvasMode === 'line') {
            const targetPoint = findClosestValidLinePoint(clickedGridPoint);

            if (!targetPoint) {
                return;
            }

            if (!tempLineStart) {
                tempLineStart = targetPoint;
                redrawCanvas();
            } else {
                if (isSamePoint(tempLineStart, targetPoint)) {
                    tempLineStart = null;
                } else {
                    const newLine = { p1: tempLineStart, p2: targetPoint };
                    if (!isLineExists(newLine)) {
                        userLines.push(newLine);
                    } else {
                        userLines = userLines.filter(existingLine => !isSameLine(existingLine, newLine));
                    }
                    tempLineStart = null;
                }
                redrawCanvas();
            }
        }
        
        saveGameState(); // <-- ì ì´ë‚˜ ì„ ì„ ê·¸ë¦¬ê³  ì§€ì› ìœ¼ë‹ˆ ìƒíƒœ ë³€ê²½ í›„ ì €ì¥!
    });

    document.getElementById('start-quiz-btn').addEventListener('click', () => {
        clearGameState(); // <-- ìƒˆ ê²Œì„ ì‹œì‘ ì‹œ ê³¼ê±° ê¸°ë¡ ì‚­ì œ!
        startQuiz();
    });

    document.getElementById('next-problem-btn').addEventListener('click', nextProblem);
    
document.getElementById('clear-canvas-btn').addEventListener('click', () => {
    document.getElementById('confirm-clear-popup-overlay').style.display = 'flex';
});

    // 'ì²« í˜ì´ì§€ë¡œ' ë²„íŠ¼ ì²˜ë¦¬ (HTMLì˜ onclick ì†ì„±ì€ ì‚­ì œí•´ì£¼ì„¸ìš”)
    document.querySelector('.home-button').addEventListener('click', () => {
        if (confirm('ì§„í–‰ ìƒí™©ì„ ì´ˆê¸°í™”í•˜ê³  ì²« í˜ì´ì§€ë¡œ ëŒì•„ê°ˆê¹Œìš”?')) {
            clearGameState(); // <-- ì²« í˜ì´ì§€ë¡œ ê°ˆ ë•Œë„ ê¸°ë¡ ì‚­ì œ!
            location.reload();
        }
    });

    document.getElementById('qr-code-btn').addEventListener('click', showQrPopup);
    document.getElementById('show-hof-btn').addEventListener('click', showHofPopup);
    document.getElementById('hof-submit-btn').addEventListener('click', submitScore);

document.getElementById('confirm-clear-yes-btn').addEventListener('click', () => {
    clearCanvas(true);
    saveGameState(); // ì´ˆê¸°í™”ëœ ìƒíƒœë¥¼ ì €ì¥!
    document.getElementById('confirm-clear-popup-overlay').style.display = 'none'; // íŒì—… ë‹«ê¸°
});

document.getElementById('confirm-clear-no-btn').addEventListener('click', () => {
    document.getElementById('confirm-clear-popup-overlay').style.display = 'none'; // íŒì—… ë‹«ê¸°
});
};

</script>
<div id="confirm-clear-popup-overlay" class="popup-overlay" style="display: none; background-color: rgba(255, 255, 255, 0.8);">
    <div class="popup-box confirm-clear-popup">
        <p>í‘œì‹œí•œ ì ê³¼ ì„ ë¶„ì„ ëª¨ë‘ ì§€ì›ë‹ˆë‹¤. <br> ê³„ì†í• ê¹Œìš”?</p>
        <div class="confirm-buttons">
            <button id="confirm-clear-yes-btn">ë„¤</button>
            <button id="confirm-clear-no-btn" class="secondary-btn">ì•„ë‹ˆìš”</button>
        </div>
    </div>
</div>
</body>
</html>

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>선대칭/점대칭도형 완전 정복</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Gowun+Dodum&display=swap" rel="stylesheet">
    <style>
        /* 기본 스타일 */
        body {
            font-family: 'Gowun Dodum', sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f4f7f6;
            color: #333;
            text-align: center;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 800px;
            text-align: center;
            margin: 20px auto;
        }
        h1 {
            color: #4b8134;
            margin-bottom: 20px;
            font-size: 2em;
        }
        h2 {
            margin-bottom: 5px;
        }
        small {
            display: block;
            font-size: 18px;
            color: #6c757d;
            margin-bottom: 20px;
            line-height: 1.5;
        }
        button {
            font-family: 'Gowun Dodum', sans-serif;
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s, transform 0.1s;
        }
        button:hover {
            transform: translateY(-1px);
        }
        .primary-btn {
            background-color: #28a745;
            color: white;
        }
        .primary-btn:hover {
            background-color: #218838;
        }
        .secondary-btn {
            background-color: #e9e9e9;
            color: #333;
            border: none;
        }
        .secondary-btn:hover {
            background-color: #d9d9d9;
        }
        #clear-canvas-btn {
            background-color: #ea9999;
            color: white;
        }
        #clear-canvas-btn:hover {
            background-color: #e06666;
        }
        .mode-btn-active {
            background-color: #ffc107;
            color: #333;
            font-weight: bold;
        }
        #setup-page, #problem-page, #final-result-page {
            display: none;
        }
        #setup-page {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .setting-group {
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
            flex-grow: 1;
        }
        .option-buttons {
            display: flex;
            flex-direction: row;
            justify-content: center;
            gap: 5px;
            margin-top: 10px;
        }
        .option-buttons button {
            flex-grow: 1;
            padding: 10px 20px;
        }
        .option-buttons button.selected {
            background-color: #ffc107;
            color: #333;
            font-weight: bold;
        }
        #grid-canvas {
            border: 2px solid #333;
            background-color: white;
            cursor: crosshair;
            margin-bottom: 20px;
            width: 100%;
            max-width: 400px;
            height: auto;
        }
        .user-dot {
            width: 8px;
            height: 8px;
            background-color: #dc3545;
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
            z-index: 10;
        }
        .problem-dot, .line-dot {
            width: 8px;
            height: 8px;
            background-color: black;
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
            z-index: 10;
        }
        .selected-line-dot {
            width: 10px;
            height: 10px;
            background-color: #ff0000;
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 5px rgba(255,0,0,0.8);
            z-index: 11;
        }
        .canvas-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
            max-width: 400px;
            height: 400px;
        }
        .canvas-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        .correct, .incorrect {
            padding: 10px;
            border-radius: 8px;
            font-weight: bold;
            margin-top: 15px;
        }
        .correct { color: #28a745; }
        .incorrect { color: #dc3545; }

        /* UI 개선을 위한 추가 스타일 */
        .quantity-display {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 40px;
            height: 40px;
            background-color: #ffc107;
            border-radius: 50%;
            font-size: 18px;
            font-weight: bold;
            color: #333;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            vertical-align: middle;
            margin: 0 10px;
        }
        
        .footer {
            margin-top: 20px;
            font-size: 12px;
            color: #ccc;
            text-align: center;
        }

        /* 메인 레이아웃 변경 */
        .main-layout {
            display: flex;
            flex-direction: row;
            gap: 20px;
            width: 100%;
            max-width: 800px;
            align-items: stretch;
            flex-wrap: wrap;
        }
        .main-layout h3 {
            text-align: center;
        }
        .left-panel {
            flex: 2;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .right-panel .setting-group, .left-panel .setting-group {
             flex-grow: 1;
        }
        
        #start-quiz-btn {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            font-size: 20px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0;
            flex-shrink: 0;
        }
        
        /* 시작 버튼 컨테이너 스타일 */
        .setting-group.start-btn-container {
            border: none;
            background-color: transparent;
        }
        
        /* 문제 페이지 헤더 스타일 */
        .problem-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        .home-button {
            background-color: #e9e9e9;
            color: #333;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            text-decoration: none;
            transition: background-color 0.3s;
        }
        .home-button:hover {
            background-color: #d9d9d9;
        }
        #problem-number {
            flex-grow: 1;
            text-align: center;
            margin: 0;
        }
        
        /* 문제 페이지 푸터 스타일 (정답 확인 및 다음 문제 버튼) */
        .problem-footer {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            width: 100%;
            margin-top: 20px;
        }
        
        /* 결과 메시지 팝업 스타일 */
        .result-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .result-popup {
            background-color: rgba(255, 255, 255, 1);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            position: relative;
            width: 80%;
            max-width: 400px;
            text-align: center;
        }
        .result-popup .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 24px;
            line-height: 20px;
            font-weight: bold;
            color: #333;
            cursor: pointer;
            background: none;
            border: none;
            padding: 5px;
        }
        .result-popup .close-btn:hover {
            color: #6c757d;
        }
        .result-popup .popup-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }
        .result-popup #popup-main-message {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 0;
            line-height: 1.5;
        }
        .result-popup #popup-detail-message {
            display: none;
        }
        .result-popup #popup-next-btn {
            margin-top: 20px;
            align-self: center;
        }
        
        /* 최종 결과 페이지 스타일 */
        .final-result-layout {
            display: flex;
            flex-direction: row;
            justify-content: space-around;
            align-items: center;
            margin: 30px 0;
            gap: 20px;
        }
        .result-left, .result-right {
            flex: 1;
            padding: 20px;
        }
        .result-left {
            border-right: 1px solid #ddd;
        }
        .result-right p {
            font-size: 1.1em;
            margin: 15px 0;
        }
        #final-accuracy {
            font-size: 4em;
            font-weight: bold;
            color: #4b8134;
            margin-top: 10px;
        }

        /* 반응형 디자인 */
        @media (max-width: 768px) {
            .main-layout {
                flex-direction: column;
            }
            .left-panel, .right-panel {
                width: 100%;
                margin-top: 20px;
            }
            .option-buttons {
                flex-direction: column;
            }
            .problem-footer {
                justify-content: center;
            }
            .final-result-layout {
                flex-direction: column;
            }
            .result-left {
                border-right: none;
                border-bottom: 1px solid #ddd;
                width: 100%;
            }
        }
    </style>
</head>
<body>

<div class="container">
    <div id="setup-page">
        <h1>선대칭/점대칭도형 완전 정복</h1>
        <h2 style="text-align: center;">문제 유형 및 개수 설정</h2>
        <small>무작위로 생성되는 새로운 문제를 <br> 원하는 만큼 연습할 수 있습니다. <br> (최소 5, 최대 50문제)</small>

        <div class="main-layout">
            <div class="left-panel">
                <div class="setting-group">
                    <h3>문제 유형 선택</h3>
                    <div id="type-select" class="option-buttons">
                        <button data-type="line" class="selected">선대칭도형</button>
                        <button data-type="point">점대칭도형</button>
                        <button data-type="both">둘 다 할래요</button>
                    </div>
                </div>

                <div class="setting-group">
                    <h3>난이도 선택</h3>
                    <div id="difficulty-select" class="option-buttons">
                        <button data-difficulty="1" class="selected">★</button>
                        <button data-difficulty="2">★★</button>
                    </div>
                </div>
            </div>

            <div class="right-panel">
                <div class="setting-group">
                    <h3>문제 개수 설정</h3>
                    <div id="quantity-control">
                        <button id="quantity-minus-5">-5</button>
                        <span id="problem-quantity" class="quantity-display">5</span>
                        <button id="quantity-plus-5">+5</button>
                    </div>
                </div>
                <div class="setting-group start-btn-container">
                    <button id="start-quiz-btn" class="primary-btn">시작!</button>
                </div>
            </div>
        </div>
    </div>
    
    <div id="problem-page">
        <div class="problem-header">
            <button class="home-button" onclick="location.reload()">🏠 첫 페이지로</button>
            <h2 id="problem-number">1번째 문제</h2>
            <div style="width: 120px;"></div>
        </div>
        <p id="problem-instruction">아래 도형은 선대칭도형입니다. 나머지 부분을 완성해 주세요.</p>
        
        <div class="canvas-wrapper">
            <canvas id="grid-canvas" width="400" height="400"></canvas>
        </div>

        <div class="canvas-controls">
            <button id="mode-vertex" class="secondary-btn mode-btn-active" onclick="setCanvasMode('vertex')">1단계: 꼭짓점 찍기</button>
            <button id="mode-line" class="secondary-btn" onclick="setCanvasMode('line')" disabled>2단계: 선분 잇기</button>
            <button id="clear-canvas-btn" class="secondary-btn">다시 풀기 (초기화)</button>
        </div>

        <div class="problem-footer">
            <button id="check-answer-btn" class="primary-btn" onclick="checkAnswer()">정답 확인하기</button>
            <button id="next-problem-btn" class="primary-btn" style="display: none;">다음 문제 도전하기</button>
        </div>
    </div>

    <div id="final-result-page">
        <h2>학습 완료</h2>
        <div class="final-result-layout">
            <div class="result-left">
                <p>나의 정확도</p>
                <div id="final-accuracy">0%</div>
            </div>
            <div class="result-right">
                <p>한 번에 맞춘 문제: <span id="correct-count">0</span>개</p>
                <p>다시 도전해 맞춘 문제: <span id="retried-count">0</span>개</p>
            </div>
        </div>
        <p><button class="primary-btn" onclick="location.reload()">새로운 학습 시작하기</button></p>
    </div>
</div>
<div class="footer">
    휴르쌤
</div>

<div id="result-popup-overlay" class="result-popup-overlay" style="display: none;">
    <div id="result-popup" class="result-popup">
        <button class="close-btn" onclick="closePopup()">&times;</button>
        <div class="popup-content">
            <p id="popup-main-message"></p>
            <p id="popup-detail-message"></p>
            <button id="popup-next-btn" class="primary-btn" onclick="nextProblem()" style="display: none;">다음 문제 도전하기</button>
        </div>
    </div>
</div>

<script>
    // 전역 변수 설정
    let selectedType = 'line';
    let totalProblems = 5;
    let currentProblem = 0;
    let canvasMode = 'vertex';
    let score = { correct: 0, retried: 0, totalAttempted: 0, isFirstAttempt: true };
    let selectedDifficulty = 1;
    
    const canvas = document.getElementById('grid-canvas');
    const ctx = canvas.getContext('2d');
    const canvasWrapper = document.querySelector('.canvas-wrapper');
    const GRID_SIZE = 20;
    const GRID_COUNT = canvas.width / GRID_SIZE;
    const HALF_COUNT = GRID_COUNT / 2;
    const CENTER_POINT = { x: HALF_COUNT, y: HALF_COUNT };
    const MIN_COORD = 3;
    const MAX_COORD = 17;
    const MIN_DIST = 2; // 최소 점 간격 (그리드 단위)
    
    const COLLINEARITY_THRESHOLD_SQ = 0.5 * 0.5; // (0.5 그리드 단위) 3점의 거리가 이 값 이하이면 일직선으로 간주.
    const MIN_ANGLE_COSINE = Math.cos(35 * Math.PI / 180); // 35도 이하의 좁은 각도 방지
    const MAX_ANGLE_COSINE = Math.cos(145 * Math.PI / 180); // 145도 이상의 둔각 방지 (거의 일직선)
    const MIN_SLOPE_MAGNITUDE_DIFF = 1.0; // 기울기 변화의 최소 크기 (x, y 변화량)

    // 현재 문제 상태
    let problemVertices = [];
    let problemLines = [];
    let userVertices = [];
    let userLines = [];
    let tempLineStart = null;
    let hoveredLine = null;

    let problemList = [];

    // 헬퍼 함수
    function isSamePoint(p1, p2) {
        if (!p1 || !p2) return false;
        return p1.x === p2.x && p1.y === p2.y;
    }
    
    function isSameLine(l1, l2) {
        if (!l1 || !l2) return false;
        const p11 = l1.p1;
        const p12 = l1.p2;
        const p21 = l2.p1;
        const p22 = l2.p2;
        
        return (isSamePoint(p11, p21) && isSamePoint(p12, p22)) || (isSamePoint(p11, p22) && isSamePoint(p12, p21));
    }
    
    function isLineExists(newLine) {
        return userLines.some(existingLine => isSameLine(existingLine, newLine));
    }

    function nextProblem() {
        closePopup();
        currentProblem++;
        loadProblem();
    }
    
    function getRandomInt(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    
    function isTooClose(newV, vertices, minDist = MIN_DIST) {
        const minDistSq = minDist ** 2;
        for (const v of vertices) {
            const distSq = (newV.x - v.x) ** 2 + (newV.y - v.y) ** 2;
            if (distSq < minDistSq) {
                return true;
            }
        }
        return false;
    }

    // 세 점이 거의 일직선상에 있는지 확인
    function isTooLinear(p1, p2, p3) {
        // 벡터 (p1->p2)와 (p2->p3)의 외적 크기를 이용
        const crossProduct = (p2.y - p1.y) * (p3.x - p2.x) - (p3.y - p2.y) * (p2.x - p1.x);
        // 세 점으로 이루어진 삼각형의 넓이가 매우 작으면 일직선으로 간주
        return Math.abs(crossProduct) < COLLINEARITY_THRESHOLD_SQ;
    }
    
    // 특정 각도 제한을 벗어나는지 확인 (너무 뾰족하거나 너무 둔각)
    function isTooSharpAngle(p1, p2, p3) {
        const v1x = p1.x - p2.x;
        const v1y = p1.y - p2.y;
        const v2x = p3.x - p2.x;
        const v2y = p3.y - p2.y;

        const dotProduct = v1x * v2x + v1y * v2y;
        
        const mag1 = Math.sqrt(v1x * v1x + v1y * v1y);
        const mag2 = Math.sqrt(v2x * v2x + v2y * v2y);
        
        if (mag1 === 0 || mag2 === 0) return true; // 같은 점이거나 너무 가까운 경우

        const cosine = dotProduct / (mag1 * mag2);
        
        if (cosine > MIN_ANGLE_COSINE || cosine < MAX_ANGLE_COSINE) return true;
        
        return false;
    }
    
    // 선대칭에서 축에 가까운 점들이 너무 미약한 기울기를 가지는지 확인 (직선 형태 방지)
    function isTooWeakSlope(p1, p2) {
        const dx = Math.abs(p2.x - p1.x);
        const dy = Math.abs(p2.y - p1.y);
        // x, y 변화량이 너무 작거나, 둘 중 하나만 너무 작아서 거의 직선에 가까운 형태 방지
        return (dx < MIN_SLOPE_MAGNITUDE_DIFF && dy < MIN_SLOPE_MAGNITUDE_DIFF) || (dx < MIN_SLOPE_MAGNITUDE_DIFF && dy > 0) || (dy < MIN_SLOPE_MAGNITUDE_DIFF && dx > 0);
    }
    
    // 기존 문제의 점들과 새 점이 일직선이 되는지 확인 (점 추가 시)
    function isProblemTooLinear(vertices, newV) {
        const len = vertices.length;
        if (len >= 2) {
            const p1 = vertices[len - 2];
            const p2 = vertices[len - 1];
            const p3 = newV;
            
            if (isTooLinear(p1, p2, p3)) {
                return true;
            }
        }
        return false;
    }
    
    // 기존 문제의 점들과 새 점이 뾰족한 각을 이루는지 확인 (점 추가 시)
    function isProblemTooSharp(vertices, newV) {
        const len = vertices.length;
        if (len >= 2) {
            const p1 = vertices[len - 2];
            const p2 = vertices[len - 1];
            const p3 = newV;
            
            // 대칭축 위의 점들은 각도 제한에서 제외 (대칭축을 이루는 선분은 허용)
            const isAxisPoint = (p) => p.x === HALF_COUNT || p.y === HALF_COUNT || (p.x === p.y && p.y > 0 && p.y < GRID_COUNT);
            
            if (isAxisPoint(p1) && isAxisPoint(p2) && isAxisPoint(p3)) {
                return false;
            }
            
            return isTooSharpAngle(p1, p2, p3);
        }
        return false;
    }
    
    function distSq(p1, p2) {
        return (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;
    }
    
    function calculateSymmetricPoint(v, type, isSlantedAxis = false, axisDirection = 'vertical') {
        let symX, symY;
        const C = HALF_COUNT;

        if (type === 'line') {
            if (isSlantedAxis) {
                symX = v.y;
                symY = v.x;
            } else if (axisDirection === 'horizontal') {
                symX = v.x;
                symY = 2 * C - v.y;
            } else { // 'vertical'
                symX = 2 * C - v.x;
                symY = v.y;
            }
        } else if (type === 'point') {
            symX = 2 * C - v.x;
            symY = 2 * C - v.y;
        } else {
            return v;
        }
        return { x: Math.round(symX), y: Math.round(symY) };
    }
    
    function createSequentialLines(vertices, close = false) {
        const lines = [];
        if (vertices.length < 2) return lines;
        
        const count = vertices.length;
        for (let i = 0; i < count; i++) {
            const p1 = vertices[i];
            const p2 = vertices[(i + 1) % count];
            
            if (!close && i === count - 1) break;
            
            lines.push({ p1: p1, p2: p2 });
        }
        return lines;
    }
    
    function findPointSymmetricBoundary(points) {
        if (points.length < 3) return points;
        const C = CENTER_POINT;
        
        const centerPoint = points.find(p => isSamePoint(p, C));
        const nonCenterPoints = points.filter(p => !isSamePoint(p, C));
        
        // 중심을 기준으로 각도 정렬
        nonCenterPoints.sort((a, b) => {
            const angleA = Math.atan2(a.y - C.y, a.x - C.x);
            const angleB = Math.atan2(b.y - C.y, b.x - C.x);
            return angleA - angleB;
        });

        let sortedPoints = [];
        if (centerPoint) {
            sortedPoints.push(centerPoint);
        }
        sortedPoints = sortedPoints.concat(nonCenterPoints);
        
        const finalPoints = sortedPoints.filter((v, i, self) => i === self.findIndex((t) => isSamePoint(t, v)));

        return finalPoints;
    }

    function sortSlantedAxisVertices(vertices) {
        const axisPoints = vertices.filter(v => v.x === v.y).sort((a, b) => a.y - b.y);
        const nonAxisPoints = vertices.filter(v => v.x !== v.y);
        
        if (axisPoints.length < 2) return vertices; // 최소 두 개의 축 점이 없으면 정렬 불가

        const p1 = axisPoints[0]; // 대칭축의 시작점
        const p2 = axisPoints[1]; // 대칭축의 끝점

        const belowAxis = nonAxisPoints.filter(p => p.y < p.x); // y = x 선 아래
        const aboveAxis = nonAxisPoints.filter(p => p.y > p.x); // y = x 선 위
        
        belowAxis.sort((a,b) => {
            // p1을 기준으로 각도 정렬
            const angleA = Math.atan2(a.y - p1.y, a.x - p1.x);
            const angleB = Math.atan2(b.y - p1.y, b.x - p1.x);
            return angleA - angleB;
        });

        aboveAxis.sort((a,b) => {
            // p2를 기준으로 각도 정렬 (반대 방향)
            const angleA = Math.atan2(a.y - p2.y, a.x - p2.x);
            const angleB = Math.atan2(b.y - p2.y, b.x - p2.x);
            return angleB - angleA; // 역순으로 정렬하여 시계방향 연결
        });
        
        return [p1, ...belowAxis, p2, ...aboveAxis];
    }


    // 랜덤 문제 생성 로직
    function generateRandomProblem(type) {
        const MAX_ATTEMPTS_PER_POINT = 100;
        
        if (type === 'line') {
            let nVertices, minCoord, maxCoord;
            let isSlantedAxis = false;
            let axisDirection = 'vertical';
            
            if (selectedDifficulty == 2) {
                isSlantedAxis = Math.random() < 0.5;
                if (isSlantedAxis) {
                    nVertices = getRandomInt(3, 4);
                    minCoord = 3;
                    maxCoord = 17;
                    axisDirection = 'slanted';
                } else {
                    nVertices = getRandomInt(5, 6);
                    minCoord = 2;
                    maxCoord = 18;
                    axisDirection = Math.random() < 0.5 ? 'vertical' : 'horizontal';
                }
            } else { // 난이도 1
                isSlantedAxis = false;
                nVertices = getRandomInt(3, 4);
                minCoord = 3;
                maxCoord = 17;
                axisDirection = Math.random() < 0.5 ? 'vertical' : 'horizontal';
            }
            
            let tempVertices = [];
            
            if (isSlantedAxis) {
                const axisMidPoint = { x: HALF_COUNT, y: HALF_COUNT };
                
                const axisLength = getRandomInt(3, 7); // 대칭축 길이
                
                const p1 = {x: axisMidPoint.x - axisLength, y: axisMidPoint.y - axisLength};
                const p2 = {x: axisMidPoint.x + axisLength, y: axisMidPoint.y + axisLength};
                
                tempVertices.push(p1); // 첫 번째 축 점 추가

                for (let i = 0; i < nVertices - 2; i++) { // 나머지 비축 점들 생성
                    let newV;
                    let success = false;
                    let attemptCount = 0;
                    while (!success && attemptCount < MAX_ATTEMPTS_PER_POINT) {
                        let x = getRandomInt(minCoord, maxCoord);
                        let y = getRandomInt(minCoord, x - 1); // y < x (y=x 축 아래)
                        
                        newV = { x: x, y: y };

                        let isValid = true;
                        
                        // 기존 점들과 너무 가까운지 확인
                        if (isTooClose(newV, tempVertices)) { isValid = false; }
                        
                        // 일직선 또는 뾰족한/둔각 각도 확인
                        if (tempVertices.length >= 2) {
                            if(isProblemTooLinear(tempVertices, newV) || isProblemTooSharp(tempVertices, newV)) {
                                isValid = false;
                            }
                        }
                        // 대칭점과의 관계도 확인
                        let symV = calculateSymmetricPoint(newV, 'line', true);
                        if (tempVertices.length > 0 && isProblemTooSharp(tempVertices.concat(newV), symV)) {
                            isValid = false;
                        }
                        
                        if (isValid) {
                            tempVertices.push(newV);
                            success = true;
                        }
                        attemptCount++;
                    }
                    if (!success) return null; // 점 생성 실패 시 문제 생성 취소
                }
                tempVertices.push(p2); // 두 번째 축 점 추가
                
                let allVertices = [...tempVertices];
                
                if (allVertices.length < 3) {
                    return null;
                }
                
                // 최종 도형이 닫힐 때의 유효성 검사 (첫 점과 끝 점 연결)
                const lastV = allVertices[allVertices.length - 1];
                const secondLastV = allVertices[allVertices.length - 2];
                const firstV = allVertices[0];

                if (isTooLinear(secondLastV, lastV, firstV) || isTooSharpAngle(secondLastV, lastV, firstV)) {
                    return null;
                }

                let allVerticesSorted = sortSlantedAxisVertices(allVertices); // 대칭축 기준으로 정렬
                
                const allLines = createSequentialLines(allVerticesSorted, false);

                // y < x 영역에 있는 선분만 초기 도형으로 사용 (대칭축 아래)
                const initialLines = allLines.filter(line => {
                    const midPoint = {x: (line.p1.x + line.p2.x)/2, y: (line.p1.y + line.p2.y)/2};
                    return midPoint.y < midPoint.x;
                });
                
                // 초기 선분에서 꼭짓점 추출
                let initialVertices = initialLines.reduce((acc, line) => {
                    if (!acc.some(v => isSamePoint(v, line.p1))) acc.push(line.p1);
                    if (!acc.some(v => isSamePoint(v, line.p2))) acc.push(line.p2);
                    return acc;
                }, []);
                
                // 초기 도형이 대칭축의 두 점을 포함하는지 확인
                const axisPointsInInitial = initialVertices.filter(v => v.x === v.y);
                if(axisPointsInInitial.length < 2) {
                    return null;
                }
                
                allVertices = allVerticesSorted; // 최종 정렬된 꼭짓점

                return {
                    type: 'line',
                    isSlantedAxis: true,
                    axisDirection: 'slanted',
                    initialVertices: initialVertices,
                    initialLines: initialLines,
                    allVertices: allVertices,
                    allLines: allLines
                };

            } else { // 수직 또는 수평 대칭축
                
                if (axisDirection === 'vertical') {
                    const pointCount = selectedDifficulty == 1 ? getRandomInt(3, 4) : getRandomInt(5, 6);
                    let nonAxisPoints = [];

                    // 대칭축 위의 시작점과 끝점
                    const axisPoint1 = { x: HALF_COUNT, y: getRandomInt(minCoord, HALF_COUNT - 2) };
                    const axisPoint2 = { x: HALF_COUNT, y: getRandomInt(HALF_COUNT + 2, maxCoord) };
                    
                    for (let i = 0; i < pointCount - 2; i++) {
                        let newV;
                        let success = false;
                        let attemptCount = 0;
                        while (!success && attemptCount < MAX_ATTEMPTS_PER_POINT) {
                            let x = getRandomInt(minCoord, HALF_COUNT - 1); // 대칭축의 왼쪽
                            let y = getRandomInt(axisPoint1.y, axisPoint2.y);
                            newV = { x: x, y: y };

                            let isValid = true;
                            // 기존 점들과 너무 가까운지 확인
                            if (isTooClose(newV, [...nonAxisPoints, axisPoint1, axisPoint2])) { isValid = false; }
                            
                            // 기울기가 너무 미약한 선분 방지
                            if (nonAxisPoints.length > 0) {
                                let lastPoint = nonAxisPoints[nonAxisPoints.length - 1];
                                if (isTooWeakSlope(lastPoint, newV)) {
                                    isValid = false;
                                }
                            }
                            // 일직선 또는 뾰족한/둔각 각도 확인
                            if (nonAxisPoints.length >= 2) {
                                if(isProblemTooLinear(nonAxisPoints, newV) || isProblemTooSharp(nonAxisPoints, newV)) {
                                    isValid = false;
                                }
                            }
                            
                            if (isValid) {
                                nonAxisPoints.push(newV);
                                success = true;
                            }
                            attemptCount++;
                        }
                        if (!success) return null;
                    }
                    nonAxisPoints.sort((a, b) => a.y - b.y); // y축 기준으로 정렬하여 순차적인 도형 생성

                    let initialVertices = [axisPoint1, ...nonAxisPoints, axisPoint2];
                    
                    if (initialVertices.length < 2) return null;

                    // 전체 꼭짓점 (대칭점 포함)
                    let allVertices = initialVertices.concat(initialVertices.map(v => calculateSymmetricPoint(v, 'line', false, axisDirection)).reverse());
                    allVertices = allVertices.filter((v, i, self) => i === self.findIndex((t) => isSamePoint(t, v))); // 중복 제거
                    
                    let initialLines = createSequentialLines(initialVertices, false);
                    
                    return {
                        type: 'line',
                        isSlantedAxis: false,
                        axisDirection: axisDirection,
                        initialVertices: initialVertices,
                        initialLines: initialLines,
                        allVertices: allVertices,
                        allLines: createSequentialLines(allVertices, true)
                    };

                } else { // horizontal
                    const pointCount = selectedDifficulty == 1 ? getRandomInt(3, 4) : getRandomInt(5, 6);
                    let nonAxisPoints = [];
                    
                    // 대칭축 위의 시작점과 끝점
                    const axisPoint1 = { x: getRandomInt(minCoord, HALF_COUNT - 2), y: HALF_COUNT };
                    const axisPoint2 = { x: getRandomInt(HALF_COUNT + 2, maxCoord), y: HALF_COUNT };

                    for (let i = 0; i < pointCount - 2; i++) {
                        let newV;
                        let success = false;
                        let attemptCount = 0;
                        while (!success && attemptCount < MAX_ATTEMPTS_PER_POINT) {
                            let x = getRandomInt(axisPoint1.x, axisPoint2.x);
                            let y = getRandomInt(minCoord, HALF_COUNT - 1); // 대칭축의 위쪽
                            newV = { x: x, y: y };
                            
                            let isValid = true;
                            if (isTooClose(newV, [...nonAxisPoints, axisPoint1, axisPoint2])) { isValid = false; }
                            
                            if (nonAxisPoints.length > 0) {
                                let lastPoint = nonAxisPoints[nonAxisPoints.length - 1];
                                if (isTooWeakSlope(lastPoint, newV)) {
                                    isValid = false;
                                }
                            }
                            if (nonAxisPoints.length >= 2) {
                                if(isProblemTooLinear(nonAxisPoints, newV) || isProblemTooSharp(nonAxisPoints, newV)) {
                                    isValid = false;
                                }
                            }
                            
                            if (isValid) {
                                nonAxisPoints.push(newV);
                                success = true;
                            }
                            attemptCount++;
                        }
                        if (!success) return null;
                    }
                    nonAxisPoints.sort((a, b) => a.x - b.x); // x축 기준으로 정렬하여 순차적인 도형 생성

                    let initialVertices = [axisPoint1, ...nonAxisPoints, axisPoint2];
                    
                    if (initialVertices.length < 2) return null;
                    
                    let allVertices = initialVertices.concat(initialVertices.map(v => calculateSymmetricPoint(v, 'line', false, axisDirection)).reverse());
                    allVertices = allVertices.filter((v, i, self) => i === self.findIndex((t) => isSamePoint(t, v)));

                    let initialLines = createSequentialLines(initialVertices, false);

                    return {
                        type: 'line',
                        isSlantedAxis: false,
                        axisDirection: axisDirection,
                        initialVertices: initialVertices,
                        initialLines: initialLines,
                        allVertices: allVertices,
                        allLines: createSequentialLines(allVertices, true)
                    };
                }
            }

        } else if (type === 'point') {
            const numPoints = (selectedDifficulty == 1) ? getRandomInt(3, 4) : getRandomInt(5, 6);
            let initialPoints = [];
            const MAX_POINT_GEN_ATTEMPTS = 50;

            let halfVertices = [];
            // 대칭의 중심을 포함할 수도 있고 아닐 수도 있음
            const hasCenter = Math.random() < 0.3; 
            
            // 초기 도형의 시작점을 중심축에서 벗어나도록 생성하여 단순한 직선 방지
            let startPoint;
            let attemptCount = 0;
            while(attemptCount < MAX_POINT_GEN_ATTEMPTS) {
                const x = getRandomInt(MIN_COORD, MAX_COORD);
                const y = getRandomInt(MIN_COORD, MAX_COORD);
                startPoint = {x: x, y: y};
                if (!isSamePoint(startPoint, CENTER_POINT) && !isTooClose(startPoint, [])) {
                    initialPoints.push(startPoint);
                    break;
                }
                attemptCount++;
            }
            if(initialPoints.length === 0) return null;

            for(let i = 0; i < numPoints - 1; i++) { // 첫 점을 제외한 나머지 점들
                let newV;
                let success = false;
                attemptCount = 0;
                while(!success && attemptCount < MAX_POINT_GEN_ATTEMPTS) {
                    let x = getRandomInt(MIN_COORD, MAX_COORD);
                    let y = getRandomInt(MIN_COORD, MAX_COORD);
                    newV = {x: x, y: y};
                    
                    if (!isSamePoint(newV, CENTER_POINT) && // 중심점과 동일하지 않고
                        !isTooClose(newV, [...initialPoints, ...halfVertices]) && // 다른 점들과 가깝지 않으며
                        !isProblemTooLinear(initialPoints.concat(halfVertices), newV) && // 일직선상에 있지 않고
                        !isProblemTooSharp(initialPoints.concat(halfVertices), newV)) { // 뾰족한 각을 이루지 않는지 확인
                        
                        halfVertices.push(newV);
                        success = true;
                    }
                    attemptCount++;
                }
                if(!success) return null;
            }
            
            // 중심 기준으로 각도 정렬 (볼록 다각형 형태 유지)
            halfVertices.sort((a, b) => {
                const angleA = Math.atan2(a.y - CENTER_POINT.y, a.x - CENTER_POINT.x);
                const angleB = Math.atan2(b.y - CENTER_POINT.y, b.x - CENTER_POINT.x);
                return angleA - angleB;
            });
            initialPoints = initialPoints.concat(halfVertices);

            let allVertices = [];
            let processed = new Set();
            
            // 중심점을 포함하는 경우
            if (hasCenter) {
                allVertices.push(CENTER_POINT);
                processed.add(`${CENTER_POINT.x},${CENTER_POINT.y}`);
            }

            // 모든 점과 대칭점을 포함
            initialPoints.forEach(p => {
                const key = `${p.x},${p.y}`;
                if (!processed.has(key)) {
                    allVertices.push(p);
                    processed.add(key);
                    const symV = calculateSymmetricPoint(p, 'point');
                    const symKey = `${symV.x},${symV.y}`;
                    if (!processed.has(symKey) && !isSamePoint(p, symV)) { // 점과 대칭점이 다를 경우에만 추가
                        allVertices.push(symV);
                        processed.add(symKey);
                    }
                }
            });

            // 최종 꼭짓점을 대칭 중심으로 정렬하여 다각형 순서 정의
            allVertices = findPointSymmetricBoundary(allVertices);

            // 생성된 도형의 모든 꼭짓점이 유효한지 최종 검사
            let isProblemValid = true;
            if (allVertices.length >= 3) {
                for (let i = 0; i < allVertices.length; i++) {
                    const len = allVertices.length;
                    const p1 = allVertices[(i - 1 + len) % len];
                    const p2 = allVertices[i];
                    const p3 = allVertices[(i + 1) % len];
                    
                    if (isTooLinear(p1, p2, p3) || isTooSharpAngle(p1, p2, p3)) {
                        isProblemValid = false;
                        break;
                    }
                }
            }
            if(!isProblemValid) return null;
            
            const allLines = createSequentialLines(allVertices, true);

            const initialLines = [];
            const initialSet = new Set(initialPoints.map(p => `${p.x},${p.y}`));
            allLines.forEach(line => {
                if(initialSet.has(`${line.p1.x},${line.p1.y}`) && initialSet.has(`${line.p2.x},${line.p2.y}`)) {
                    initialLines.push(line);
                }
            });
            
            return {
                type: 'point',
                initialVertices: initialPoints,
                initialLines: initialLines,
                allVertices: allVertices,
                allLines: allLines
            };
        }
        return null;
    }


    // 1. 설정 및 시작
    function initializeSetupListeners() {
        document.querySelectorAll('#type-select button').forEach(button => {
            button.addEventListener('click', handleTypeSelect);
        });
        document.querySelectorAll('#difficulty-select button').forEach(button => {
            button.addEventListener('click', handleDifficultySelect);
        });
        document.getElementById('quantity-minus-5').addEventListener('click', () => changeQuantity(-5));
        document.getElementById('quantity-plus-5').addEventListener('click', () => changeQuantity(5));
    }

    function handleTypeSelect(event) {
        document.querySelectorAll('#type-select button').forEach(b => b.classList.remove('selected'));
        event.currentTarget.classList.add('selected');
        selectedType = event.currentTarget.getAttribute('data-type');
    }
    
    function handleDifficultySelect(event) {
        document.querySelectorAll('#difficulty-select button').forEach(b => b.classList.remove('selected'));
        event.currentTarget.classList.add('selected');
        selectedDifficulty = event.currentTarget.getAttribute('data-difficulty');
    }

    function changeQuantity(delta) {
        const current = parseInt(document.getElementById('problem-quantity').textContent);
        let newQuantity = current + delta;
        if (newQuantity < 5) newQuantity = 5;
        if (newQuantity > 50) newQuantity = 50;
        document.getElementById('problem-quantity').textContent = newQuantity;
        totalProblems = newQuantity;
    }

    function startQuiz() {
        const problemsToGenerate = totalProblems;
        problemList = [];
        let generatedVertexStrings = new Set();
        let attempt = 0;
        const MAX_ATTEMPTS = problemsToGenerate * 20; // 문제 생성 시도 횟수 제한

        while (problemList.length < problemsToGenerate && attempt < MAX_ATTEMPTS) {
            let type;
            if (selectedType === 'both') {
                type = Math.random() < 0.5 ? 'line' : 'point';
            } else {
                type = selectedType;
            }
            
            const newProblem = generateRandomProblem(type);
            
            if (newProblem && newProblem.initialVertices.length >= 2) {
                // 문제의 고유성을 위해 초기 꼭짓점 배열을 정규화하여 비교
                const vertexString = JSON.stringify(newProblem.initialVertices.map(v => `${v.x},${v.y}`).sort());
                if (!generatedVertexStrings.has(vertexString)) {
                    problemList.push(newProblem);
                    generatedVertexStrings.add(vertexString);
                }
            }
            attempt++;
        }
        
        totalProblems = problemList.length; // 실제로 생성된 문제 개수로 업데이트
        
        if (totalProblems === 0) {
            alert('문제 생성에 실패했습니다. 다른 설정으로 다시 시도해 주세요.');
            location.reload();
            return;
        }
        
        currentProblem = 0;
        score.isFirstAttempt = true;
        
        document.getElementById('setup-page').style.display = 'none';
        document.getElementById('problem-page').style.display = 'block';
        
        loadProblem();
    }

    function loadProblem() {
        if (currentProblem >= totalProblems) {
            showFinalResult();
            return;
        }

        const currentP = problemList[currentProblem];
        const pType = currentP.type === 'line' ? '선대칭' : '점대칭';
        
        document.getElementById('problem-number').textContent = `${currentProblem + 1}번째 문제 (${pType})`;
        document.getElementById('problem-instruction').innerHTML = `아래 도형은 ${pType}도형입니다. 나머지 부분을 완성해 주세요.`;
        
        const checkBtn = document.getElementById('check-answer-btn');
        const nextBtn = document.getElementById('next-problem-btn');
        checkBtn.style.display = 'block';
        nextBtn.style.display = 'none';

        closePopup();
        
        score.isFirstAttempt = true;

        problemVertices = currentP.initialVertices;
        problemLines = currentP.initialLines;
        userVertices = [];
        userLines = [];
        tempLineStart = null;
        hoveredLine = null;
        
        setCanvasMode('vertex');
        
        clearCanvas(false);
    }

    function clearCanvas(clearUserDrawing) {
        if (clearUserDrawing) {
            userVertices = [];
            userLines = [];
            tempLineStart = null;
            hoveredLine = null;
        }
        // HTML 점 요소를 제거
        document.querySelectorAll('.user-dot').forEach(dot => dot.remove());
        
        redrawCanvas();
        setCanvasMode('vertex');
        closePopup();
        
        // 버튼 상태를 정답 확인하기로 리셋
        const checkBtn = document.getElementById('check-answer-btn');
        const nextBtn = document.getElementById('next-problem-btn');
        checkBtn.style.display = 'block';
        nextBtn.style.display = 'none';
    }
    
    // 2. 캔버스 그리기 및 모드 제어
    function renderProblemVertices() {
        document.querySelectorAll('.problem-dot').forEach(dot => dot.remove());
        problemVertices.forEach((v) => {
            const dot = document.createElement('div');
            dot.className = 'problem-dot';
            dot.style.left = `${v.x * GRID_SIZE}px`;
            dot.style.top = `${v.y * GRID_SIZE}px`;
            canvasWrapper.appendChild(dot);
        });
    }

    function drawGrid() {
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 0.5;
        
        ctx.setLineDash([1, 4]); // 점선
        
        for (let x = 0; x <= canvas.width; x += GRID_SIZE) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
        }
        for (let y = 0; y <= canvas.height; y += GRID_SIZE) {
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
        }
        
        ctx.setLineDash([]); // 다시 실선

        // 대칭축 그리기
        if (problemList.length > currentProblem) {
            const currentP = problemList[currentProblem];
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 2;
            if (currentP.type === 'line') {
                if (currentP.isSlantedAxis) { // 기울어진 대칭축 (y=x)
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(canvas.width, canvas.height);
                    ctx.stroke();
                } else if (currentP.axisDirection === 'vertical') { // 수직 대칭축
                    const centerX = canvas.width / 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX, 0);
                    ctx.lineTo(centerX, canvas.height);
                    ctx.stroke();
                } else if (currentP.axisDirection === 'horizontal') { // 수평 대칭축
                    const centerY = canvas.height / 2;
                    ctx.beginPath();
                    ctx.moveTo(0, centerY);
                    ctx.lineTo(canvas.width, centerY);
                    ctx.stroke();
                }
            } else if (currentP.type === 'point') { // 점대칭의 중심점
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
                ctx.fillStyle = '#ff0000';
                ctx.fill();
            }
        }
    }

    function drawLines(lines, color) {
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        lines.forEach(line => {
            ctx.beginPath();
            ctx.moveTo(line.p1.x * GRID_SIZE, line.p1.y * GRID_SIZE);
            ctx.lineTo(line.p2.x * GRID_SIZE, line.p2.y * GRID_SIZE);
            ctx.stroke();
        });
    }

    function redrawCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();

        drawLines(problemLines, '#007bff');
        drawLines(userLines, '#28a745');
        
        if (hoveredLine) {
            ctx.save();
            ctx.strokeStyle = 'rgba(234, 153, 153, 0.7)'; // 요청하신 #ea9999 색상
            ctx.lineWidth = 6;
            ctx.shadowColor = '#ea9999'; // 붉은 글로우
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.moveTo(hoveredLine.p1.x * GRID_SIZE, hoveredLine.p1.y * GRID_SIZE);
            ctx.lineTo(hoveredLine.p2.x * GRID_SIZE, hoveredLine.p2.y * GRID_SIZE);
            ctx.stroke();
            ctx.restore();
        }

        renderProblemVertices();

        if (canvasMode === 'line') {
            renderPointsForLineMode();
        } else {
             renderUserVertices();
        }
    }

    function renderPointsForLineMode() {
        // 기존 점들 제거
        document.querySelectorAll('.user-dot').forEach(dot => dot.remove());
        document.querySelectorAll('.line-dot').forEach(dot => dot.remove());
        document.querySelectorAll('.selected-line-dot').forEach(dot => dot.remove());

        // 문제 점 + 사용자 점 모두 표시
        const allPoints = [...problemVertices, ...userVertices].filter((v, i, self) => i === self.findIndex(t => isSamePoint(t, v)));
        
        allPoints.forEach((v) => {
            const dot = document.createElement('div');
            dot.className = (tempLineStart && isSamePoint(v, tempLineStart)) ? 'selected-line-dot' : 'line-dot';
            dot.style.left = `${v.x * GRID_SIZE}px`;
            dot.style.top = `${v.y * GRID_SIZE}px`;
            canvasWrapper.appendChild(dot);
        });
    }

    function renderUserVertices() {
        // 기존 점들 제거
        document.querySelectorAll('.user-dot').forEach(dot => dot.remove());
        document.querySelectorAll('.line-dot').forEach(dot => dot.remove());
        document.querySelectorAll('.selected-line-dot').forEach(dot => dot.remove());

        userVertices.forEach((v) => {
            const dot = document.createElement('div');
            dot.className = 'user-dot';
            dot.style.left = `${v.x * GRID_SIZE}px`;
            dot.style.top = `${v.y * GRID_SIZE}px`;
            canvasWrapper.appendChild(dot);
        });
    }

    function isVertexOnProblemBoundary(v) {
        return problemVertices.some(pv => isSamePoint(pv, v));
    }
    
    function showPopup(mainMessage, detailMessage, isCorrect) {
        const popupOverlay = document.getElementById('result-popup-overlay');
        const popupMainMessage = document.getElementById('popup-main-message');
        const popupDetailMessage = document.getElementById('popup-detail-message');
        const popupNextBtn = document.getElementById('popup-next-btn');

        if (isCorrect) {
            popupMainMessage.innerHTML = mainMessage;
            popupMainMessage.className = 'correct';
            popupDetailMessage.style.display = 'none';
            popupNextBtn.style.display = 'block';
        } else {
            popupMainMessage.innerHTML = `${mainMessage}<br><span style="font-size: 80%;">${detailMessage}</span>`;
            popupMainMessage.className = 'incorrect';
            popupDetailMessage.style.display = 'none';
            popupNextBtn.style.display = 'none';
        }
        
        popupOverlay.style.display = 'flex';
    }

    function closePopup() {
        const popupOverlay = document.getElementById('result-popup-overlay');
        popupOverlay.style.display = 'none';
    }

    // 3. 정답 확인 및 결과
    function checkAnswer() {
        const currentP = problemList[currentProblem];
        const problemType = currentP.type;
        
        let verticesAreCorrect = checkVerticesSymmetry(problemType);
        let isLinesCorrect = false;

        if (verticesAreCorrect) {
            if (problemType === 'line') {
                isLinesCorrect = checkLineSymmetryLines(currentP);
            } else if (problemType === 'point') {
                isLinesCorrect = checkPointSymmetryLines(currentP);
            }
        }
        
        if (verticesAreCorrect && isLinesCorrect) {
            showPopup('정답입니다🎉', '', true);
            
            if (score.isFirstAttempt) { score.correct++; } else { score.retried++; }
            score.totalAttempted++;
            
            // 정답 시 메인 화면의 버튼을 '다음 문제 도전하기'로 변경
            document.getElementById('check-answer-btn').style.display = 'none';
            document.getElementById('next-problem-btn').style.display = 'block';

        } else {
            let detailMessage;
            
            if (!verticesAreCorrect) {
                detailMessage = '꼭짓점의 위치나 개수가 잘못되었어요.';
            } else if (!isLinesCorrect) {
                detailMessage = '도형이 대칭을 이루지 않거나 빠뜨린 선분이 있어요.';
            } else {
                detailMessage = '꼭짓점이나 선분 연결에 오류가 있어 대칭도형이 완성되지 않았습니다.';
            }

            showPopup('다시 생각해 볼까요?', detailMessage, false);
            score.isFirstAttempt = false;
            
            document.getElementById('check-answer-btn').style.display = 'block';
            document.getElementById('next-problem-btn').style.display = 'none';
        }
    }

    function checkVerticesSymmetry(problemType) {
        const currentP = problemList[currentProblem];
        const isSlantedAxis = (currentP.type === 'line' && currentP.isSlantedAxis);
        
        // 문제 점과 사용자 점을 합쳐서 최종 꼭짓점 목록 생성
        const allProblemAndUserVerticesSet = new Map();
        [...problemVertices, ...userVertices].forEach(v => {
            const key = `${Math.round(v.x)},${Math.round(v.y)}`;
            if (!allProblemAndUserVerticesSet.has(key)) {
                allProblemAndUserVerticesSet.set(key, { x: Math.round(v.x), y: Math.round(v.y) });
            }
        });
        const finalVertices = Array.from(allProblemAndUserVerticesSet.values());
        
        const numVertices = finalVertices.length;
        
        // 선대칭 도형의 경우 대칭축 위의 점 개수 확인
        if (problemType === 'line') {
            const axisDirection = currentP.axisDirection;
            let boundaryVerticesCount;

            if (isSlantedAxis) {
                boundaryVerticesCount = finalVertices.filter(v => v.x === v.y).length;
            } else if (axisDirection === 'vertical') {
                boundaryVerticesCount = finalVertices.filter(v => v.x === HALF_COUNT).length;
            } else if (axisDirection === 'horizontal') {
                boundaryVerticesCount = finalVertices.filter(v => v.y === HALF_COUNT).length;
            }
            
            const nonBoundaryCount = numVertices - boundaryVerticesCount;

            // 대칭축 위에 있지 않은 점은 항상 짝수여야 함
            if (nonBoundaryCount % 2 !== 0) {
                return false;
            }
        }
        
        let symmetricPairs = new Map();
        for (const v of finalVertices) {
            const key = `${v.x},${v.y}`;
            if (symmetricPairs.has(key)) continue; // 이미 대칭쌍을 찾은 점은 건너뛰기

            const symmetricV = calculateSymmetricPoint(v, problemType, isSlantedAxis, currentP.axisDirection);
            
            if (isSamePoint(v, symmetricV)) { // 점 자체가 대칭축/중심에 있는 경우
                symmetricPairs.set(key, true);
                continue;
            }

            // 대칭점이 최종 꼭짓점 목록에 있는지 확인
            const symmetricExists = finalVertices.some(av => isSamePoint(av, symmetricV));

            if (!symmetricExists) return false; // 대칭점이 없으면 오답
            
            symmetricPairs.set(key, true);
            symmetricPairs.set(`${symmetricV.x},${symmetricV.y}`, true); // 대칭쌍으로 표시
        }
        return true;
    }
    
    function checkLineSymmetryLines(currentP) {
        // 초기 도형의 대칭 선분들을 계산
        const correctSymmetricLines = currentP.initialLines.map(line => ({
            p1: calculateSymmetricPoint(line.p1, 'line', currentP.isSlantedAxis, currentP.axisDirection),
            p2: calculateSymmetricPoint(line.p2, 'line', currentP.isSlantedAxis, currentP.axisDirection)
        }));
        
        if (userLines.length !== correctSymmetricLines.length) {
            return false;
        }

        // 사용자 선분이 모두 정답 대칭 선분들과 일치하는지 확인
        for (const userLine of userLines) {
            const match = correctSymmetricLines.some(correctLine => isSameLine(userLine, correctLine));
            if (!match) {
                return false;
            }
        }
        
        return true;
    }
    
    function checkPointSymmetryLines(currentP) {
        // 모든 점(문제 점 + 사용자 점)을 취합하여 점대칭 도형의 최종 경계선을 생성
        const allUserVertices = [...problemVertices, ...userVertices].filter((v, i, self) => i === self.findIndex(t => isSamePoint(t, v)));
        const userVerticesSorted = findPointSymmetricBoundary(allUserVertices); // 중심 기준으로 정렬
        const userLinesGenerated = createSequentialLines(userVerticesSorted, true); // 닫힌 도형 선분 생성
        
        const correctLines = currentP.allLines; // 문제에서 정의한 정답 선분들
        
        if (userLinesGenerated.length !== correctLines.length) {
            return false;
        }
        
        // 생성된 사용자 선분들이 정답 선분들과 일치하는지 확인
        const correctLinesCopy = [...correctLines];
        
        for (const userLine of userLinesGenerated) {
            const matchIndex = correctLinesCopy.findIndex(correctLine => isSameLine(userLine, correctLine));
            if (matchIndex === -1) {
                return false; // 일치하는 선분이 없으면 오답
            }
            correctLinesCopy.splice(matchIndex, 1); // 일치하는 선분 제거 (중복 검사 방지)
        }
        
        return correctLinesCopy.length === 0; // 모든 정답 선분이 매칭되었는지 확인
    }
    
    function findClosestValidLinePoint(v) {
        const allTargetVertices = [
            ...problemVertices,
            ...userVertices
        ];
        
        if (problemList.length > currentProblem && problemList[currentProblem].type === 'point') {
            allTargetVertices.push(CENTER_POINT); // 점대칭의 경우 중심점도 선분 연결 대상으로 포함
        }

        let closestPoint = null;
        let minDistSq = Infinity;

        for (const p of allTargetVertices) {
            const dist = distSq(v, p);
            if (dist < minDistSq) {
                minDistSq = dist;
                closestPoint = p;
            }
        }
        return closestPoint;
    }
    
    function setCanvasMode(mode) {
        canvasMode = mode;
        const vertexBtn = document.getElementById('mode-vertex');
        const lineBtn = document.getElementById('mode-line');

        vertexBtn.classList.remove('mode-btn-active');
        lineBtn.classList.remove('mode-btn-active');
        
        const canStartLineDrawing = userVertices.length >= 1 || problemVertices.length > 1;

        if (mode === 'vertex') {
            vertexBtn.classList.add('mode-btn-active');
            tempLineStart = null;
        } else { // 'line' mode
            lineBtn.classList.add('mode-btn-active');
            vertexBtn.disabled = false; // 선 잇기 모드에서도 꼭짓점 찍기 모드로 돌아갈 수 있도록 활성화
        }
        
        document.getElementById('mode-line').disabled = !canStartLineDrawing; // 선 잇기 모드 활성화 조건
        redrawCanvas();
    }
    
    function renderUserVertices() {
        document.querySelectorAll('.user-dot').forEach(dot => dot.remove());
        document.querySelectorAll('.line-dot').forEach(dot => dot.remove());
        document.querySelectorAll('.selected-line-dot').forEach(dot => dot.remove());

        userVertices.forEach((v) => {
            const dot = document.createElement('div');
            dot.className = 'user-dot';
            dot.style.left = `${v.x * GRID_SIZE}px`;
            dot.style.top = `${v.y * GRID_SIZE}px`;
            canvasWrapper.appendChild(dot);
        });
    }

    function showFinalResult() {
        document.getElementById('problem-page').style.display = 'none';
        document.getElementById('final-result-page').style.display = 'block';
        
        const total = totalProblems;
        const accuracy = total > 0 ? ((score.correct / total) * 100).toFixed(1) : 0;

        document.getElementById('correct-count').textContent = score.correct;
        document.getElementById('retried-count').textContent = score.retried;
        document.getElementById('final-accuracy').textContent = `${accuracy}%`;
    }

    function handleCanvasMouseMove(event) {
        // 정답 확인 후 다음 문제 버튼이 활성화된 상태에서는 선분 삭제 기능 비활성화
        if (document.getElementById('check-answer-btn').style.display === 'none' && document.getElementById('next-problem-btn').style.display === 'block') {
            if (hoveredLine) {
                hoveredLine = null;
                canvas.style.cursor = 'default';
                redrawCanvas();
            }
            return;
        }
        
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const mousePoint = { x: x / GRID_SIZE, y: y / GRID_SIZE };

        let bestLine = null;
        let minDistSq = 0.25; // 호버 감도 (0.5 그리드 단위)

        for (const line of userLines) {
            const p1 = line.p1;
            const p2 = line.p2;
            const lineLengthSq = distSq(p1, p2);

            if (lineLengthSq === 0) continue;

            // 마우스 위치에서 선분까지의 최단 거리 계산
            let t = ((mousePoint.x - p1.x) * (p2.x - p1.x) + (mousePoint.y - p1.y) * (p2.y - p1.y)) / lineLengthSq;
            
            // 0.2 < t < 0.8 Ensures we are in the middle 60% of the line
            // 점과 너무 가까운 부분에서는 글로우가 생기지 않도록 중간 60% 영역에서만 감지
            if (t > 0.2 && t < 0.8) {
                const closestPointOnLine = {
                    x: p1.x + t * (p2.x - p1.x),
                    y: p1.y + t * (p2.y - p1.y)
                };
                const distanceSq = distSq(mousePoint, closestPointOnLine);
                if (distanceSq < minDistSq) {
                    minDistSq = distanceSq;
                    bestLine = line;
                }
            }
        }
        
        if (!isSameLine(hoveredLine, bestLine)) { // 호버 상태가 변경되었을 경우만 다시 그리기
            hoveredLine = bestLine;
            redrawCanvas();
        }

        if (hoveredLine) {
            canvas.style.cursor = 'pointer'; // 선분 위에 있으면 포인터
        } else if (canvasMode === 'line') {
            canvas.style.cursor = 'pointer'; // 선 잇기 모드에서는 항상 포인터
        } else {
            canvas.style.cursor = 'crosshair'; // 기본 크로스헤어
        }
    }


    window.onload = () => {
        document.getElementById('problem-quantity').textContent = totalProblems;
        canvasWrapper.style.width = `${canvas.width}px`;
        canvasWrapper.style.height = `${canvas.height}px`;
        document.getElementById('mode-line').disabled = true;
        
        initializeSetupListeners();
        
        canvas.addEventListener('mousemove', handleCanvasMouseMove);
        canvas.addEventListener('mouseleave', () => {
            if (hoveredLine) {
                hoveredLine = null;
                redrawCanvas();
            }
            canvas.style.cursor = 'default'; // 캔버스 밖으로 나가면 기본 커서
        });

        canvas.addEventListener('click', (event) => {
            // 정답 확인 후 다음 문제 버튼이 활성화된 상태에서는 클릭 비활성화
            if (document.getElementById('check-answer-btn').style.display === 'none' && document.getElementById('next-problem-btn').style.display === 'block') return;

            if (hoveredLine) { // 선분이 호버된 상태에서 클릭하면 삭제
                userLines = userLines.filter(line => !isSameLine(line, hoveredLine));
                hoveredLine = null;
                handleCanvasMouseMove(event); // 호버 상태 즉시 업데이트
                redrawCanvas();
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const gridX = Math.round(x / GRID_SIZE);
            const gridY = Math.round(y / GRID_SIZE);
            if (gridX < 0 || gridX > GRID_COUNT || gridY < 0 || gridY > GRID_COUNT) return;

            const clickedGridPoint = { x: gridX, y: gridY };

            if (canvasMode === 'vertex') {
                if (isVertexOnProblemBoundary(clickedGridPoint)) {
                    return; // 문제로 주어진 점은 삭제하거나 옮길 수 없음
                }

                const existingIndex = userVertices.findIndex(v => isSamePoint(v, clickedGridPoint));
                if (existingIndex > -1) { // 이미 찍힌 점이면 제거
                    userVertices.splice(existingIndex, 1);
                    // 점 삭제 시 해당 점을 포함하는 선분도 모두 제거
                    userLines = userLines.filter(line =>
                        !(isSamePoint(line.p1, clickedGridPoint) || isSamePoint(line.p2, clickedGridPoint))
                    );
                } else { // 새로운 점이면 추가
                    userVertices.push(clickedGridPoint);
                }
                redrawCanvas();

            } else if (canvasMode === 'line') {
                const targetPoint = findClosestValidLinePoint(clickedGridPoint); // 가장 가까운 유효한 점 찾기

                if (!targetPoint) {
                    return; // 연결할 점이 없으면 아무것도 안 함
                }

                if (!tempLineStart) { // 선분 시작점 선택
                    tempLineStart = targetPoint;
                    redrawCanvas();
                } else { // 선분 끝점 선택 (선분 연결)
                    if (isSamePoint(tempLineStart, targetPoint)) { // 시작점과 같은 점을 다시 클릭하면 선택 취소
                        tempLineStart = null;
                    } else {
                        const newLine = { p1: tempLineStart, p2: targetPoint };
                        if (!isLineExists(newLine)) { // 이미 존재하는 선분이면 추가하지 않음
                            userLines.push(newLine);
                        } else { // 존재하는 선분이면 삭제
                            userLines = userLines.filter(existingLine => !isSameLine(existingLine, newLine));
                        }
                        tempLineStart = null; // 선분 연결 후 시작점 초기화
                    }
                    redrawCanvas();
                }
            }
        });

        document.getElementById('start-quiz-btn').addEventListener('click', startQuiz);
        document.getElementById('next-problem-btn').addEventListener('click', nextProblem);
        
        document.getElementById('clear-canvas-btn').addEventListener('click', () => clearCanvas(true));

        document.getElementById('quantity-minus-5').addEventListener('click', () => changeQuantity(-5));
        document.getElementById('quantity-plus-5').addEventListener('click', () => changeQuantity(5));


        document.getElementById('setup-page').style.display = 'flex';
    };
</script>

</body>
</html>

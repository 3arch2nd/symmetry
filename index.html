<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ëŒ€ì¹­ ë„í˜• ì™„ì„±í•˜ê¸° í•™ìŠµ V80 (ë°˜ì‘í˜• ë””ìì¸)</title>
    <style>
        /* ğŸ¨ ê¸°ë³¸ ìŠ¤íƒ€ì¼ */
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* ì „ì²´ í™”ë©´ ë†’ì´ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ë³€ê²½ */
            margin: 0;
            background-color: #f4f7f6;
            color: #333;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 800px;
            text-align: center;
            margin: 20px auto; /* ìƒí•˜ ì—¬ë°± ì¶”ê°€ */
        }
        h1 {
            color: #007bff;
            margin-bottom: 20px;
            font-size: 2em;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s, transform 0.1s;
        }
        button:hover {
            transform: translateY(-1px);
        }
        .primary-btn {
            background-color: #28a745;
            color: white;
        }
        .primary-btn:hover {
            background-color: #218838;
        }
        .secondary-btn {
            background-color: #6c757d;
            color: white;
        }
        .secondary-btn:hover {
            background-color: #5a6268;
        }
        .mode-btn-active {
            background-color: #ffc107;
            color: #333;
            font-weight: bold;
        }
        #setup-page, #problem-page, #final-result-page {
            display: none;
        }
        #setup-page {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .setting-group {
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 8px;
            text-align: left;
        }
        .option-buttons button.selected {
            background-color: #ffc107;
            color: #333;
            font-weight: bold;
        }
        #grid-canvas {
            border: 2px solid #333;
            background-color: white;
            cursor: crosshair;
            margin-bottom: 20px;
            width: 100%; /* ìº”ë²„ìŠ¤ ë„ˆë¹„ë¥¼ ë¶€ëª¨ì— ë§ì¶¤ */
            max-width: 400px; /* ìµœëŒ€ ë„ˆë¹„ ì„¤ì • */
            height: auto; /* ë¹„ìœ¨ ìœ ì§€ë¥¼ ìœ„í•´ ë†’ì´ ìë™ ì„¤ì • */
        }
        .user-dot {
            width: 8px;
            height: 8px;
            background-color: #dc3545;
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
            z-index: 10;
        }
        .canvas-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }
        .canvas-controls {
            display: flex;
            flex-wrap: wrap; /* ë²„íŠ¼ì´ ë„˜ì¹  ê²½ìš° ë‹¤ìŒ ì¤„ë¡œ ì´ë™ */
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        .correct, .incorrect {
            padding: 10px;
            border: 1px solid;
            border-radius: 8px;
            font-weight: bold;
            margin-top: 15px;
        }
        .correct { color: #28a745; border-color: #28a745; }
        .incorrect { color: #dc3545; border-color: #dc3545; }

        /* --- ë°˜ì‘í˜• ë””ìì¸ --- */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            h1 {
                font-size: 1.5em;
            }
            button {
                font-size: 14px;
                padding: 8px 16px;
            }
            .canvas-controls button {
                flex-grow: 1; /* ì‘ì€ í™”ë©´ì—ì„œ ë²„íŠ¼ì´ ê°€ë¡œë¡œ ê½‰ ì°¨ê²Œ */
                max-width: none;
            }
        }
    </style>
</head>
<body>

<div class="container">
    <h1>ğŸ“ ëŒ€ì¹­ ë„í˜• ì™„ì„±í•˜ê¸° í•™ìŠµ ğŸ’¡</h1>

    <div id="setup-page">
        <h2>ë¬¸ì œ ìœ í˜• ë° ê°œìˆ˜ ì„¤ì •</h2>
        
        <div class="setting-group">
            <h3>1) ë¬¸ì œ ìœ í˜• ì„ íƒ</h3>
            <div id="type-select" class="option-buttons">
                <button data-type="line">ì„ ëŒ€ì¹­ë„í˜• â†”ï¸</button>
                <button data-type="point">ì ëŒ€ì¹­ë„í˜• ğŸ”„</button>
                <button data-type="both" class="selected">ë‘˜ ë‹¤ ğŸ”€</button>
            </div>
        </div>

        <div class="setting-group">
            <h3>2) ë‚œì´ë„ ì„ íƒ</h3>
            <div id="difficulty-select" class="option-buttons">
                <button data-difficulty="1" class="selected">â­ï¸</button>
                <button data-difficulty="2">â­â­</button>
            </div>
        </div>

        <div class="setting-group">
            <h3>3) ë¬¸ì œ ê°œìˆ˜ ì„¤ì •</h3>
            <div id="quantity-control">
                <button id="quantity-minus-5">-5</button>
                <span id="problem-quantity">10</span>
                <button id="quantity-plus-5">+5</button>
            </div>
            <small>ë¬´ì‘ìœ„ë¡œ ìƒì„±ë˜ëŠ” ìƒˆë¡œìš´ ë¬¸ì œë¥¼ ì›í•˜ëŠ” ë§Œí¼ ì—°ìŠµí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</small>
        </div>
        
        <button id="start-quiz-btn" class="primary-btn">âœ… ì ìš©í•˜ê¸° ë° ì‹œì‘</button>
    </div>
    
    <div id="problem-page">
        <h2 id="problem-number">1ë²ˆì§¸ ë¬¸ì œ</h2>
        <p id="problem-instruction">ì•„ë˜ ë„í˜•ì€ ì„ ëŒ€ì¹­ë„í˜•ì…ë‹ˆë‹¤. ë‚˜ë¨¸ì§€ ë¶€ë¶„ì„ ì™„ì„±í•´ ì£¼ì„¸ìš”. ğŸ“</p>
        
        <div class="canvas-wrapper">
            <canvas id="grid-canvas" width="400" height="400"></canvas>
        </div>

        <div class="canvas-controls">
            <button id="mode-vertex" class="secondary-btn mode-btn-active" onclick="setCanvasMode('vertex')">ğŸ“ 1ë‹¨ê³„: ê¼­ì§“ì  ì°ê¸°</button>
            <button id="mode-line" class="secondary-btn" onclick="setCanvasMode('line')" disabled>â– 2ë‹¨ê³„: ì„ ë¶„ ì‡ê¸°</button>
            <button id="clear-canvas-btn" class="secondary-btn">ğŸ—‘ï¸ ì´ˆê¸°í™”</button>
        </div>

        <div id="result-message" style="display: none;"></div>
        
        <button id="check-answer-btn" class="primary-btn" onclick="checkAnswer()">âœ”ï¸ ì •ë‹µ í™•ì¸í•˜ê¸°</button>
        
        <button id="next-problem-btn" class="primary-btn" style="display: none;">â¡ï¸ ë‹¤ìŒ ë¬¸ì œ ë„ì „í•˜ê¸°</button>
        <button id="reset-drawing-btn" class="secondary-btn" style="display: none;">ğŸ”„ ë‹¤ì‹œ í’€ê¸° (ì´ˆê¸°í™”)</button>
    </div>

    <div id="final-result-page">
        <h2>ğŸ† í•™ìŠµ ì™„ë£Œ!</h2>
        <p>âœ… **í•œ ë²ˆì— ë§ì¶˜ ë¬¸ì œ ìˆ˜:** <span id="correct-count">0</span>ê°œ</p>
        <p>ğŸ”„ **ë‹¤ì‹œ ë„ì „í•˜ì—¬ ë§ì¶˜ ë¬¸ì œ ìˆ˜:** <span id="retried-count">0</span>ê°œ</p>
        <hr>
        <p>ë‚˜ì˜ **ì •í™•ë„:**</p>
        <div id="final-accuracy">0%</div>
        <small>ì •í™•ë„ = (í•œë²ˆì— ë§ì¶˜ ë¬¸ì œ ìˆ˜ / ì „ì²´ ë¬¸ì œ ìˆ˜) * 100</small>
        <p><button class="primary-btn" onclick="location.reload()">ìƒˆë¡œìš´ í•™ìŠµ ì‹œì‘í•˜ê¸°</button></p>
    </div>
</div>

<script>
    // âš™ï¸ ì „ì—­ ë³€ìˆ˜ ì„¤ì •
    let selectedType = 'both'; 
    let totalProblems = 10;
    let currentProblem = 0;
    let canvasMode = 'vertex'; 
    let score = { correct: 0, retried: 0, totalAttempted: 0, isFirstAttempt: true };
    let selectedDifficulty = 1;
    
    const canvas = document.getElementById('grid-canvas');
    const ctx = canvas.getContext('2d');
    const canvasWrapper = document.querySelector('.canvas-wrapper');
    const GRID_SIZE = 20; 
    const GRID_COUNT = canvas.width / GRID_SIZE; 
    const HALF_COUNT = GRID_COUNT / 2; 
    const CENTER_POINT = { x: HALF_COUNT, y: HALF_COUNT }; // (10, 10)
    const MIN_COORD = 3; 
    const MAX_COORD = 17; 
    const MIN_DIST = 2; 
    
    const COLLINEARITY_THRESHOLD = 6; 
    const MIN_ANGLE_COSINE = Math.cos(60 * Math.PI / 180); 

    // ğŸ§© í˜„ì¬ ë¬¸ì œ ìƒíƒœ
    let problemVertices = []; 
    let problemLines = []; 
    let userVertices = [];   
    let userLines = [];      
    let tempLineStart = null; 

    let problemList = []; 

    // --- í—¬í¼ í•¨ìˆ˜ ---
    function isSamePoint(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
    }
    
    function isSameLine(l1, l2) {
        const normalize = (p1, p2) => {
            const key1 = `${p1.x},${p1.y}`;
            const key2 = `${p2.x},${p2.y}`;
            if (key1 < key2) {
                return [p1, p2];
            } else if (key2 < key1) {
                return [p2, p1];
            } else {
                return [p1, p2];
            }
        };

        const [n1p1, n1p2] = normalize(l1.p1, l1.p2);
        const [n2p1, n2p2] = normalize(l2.p1, l2.p2);
        
        return isSamePoint(n1p1, n2p1) && isSamePoint(n1p2, n2p2);
    }
    
    function isLineExists(newLine) {
        return userLines.some(existingLine => isSameLine(existingLine, newLine));
    }

    function nextProblem() { 
        currentProblem++;
        loadProblem();
    }
    
    function getRandomInt(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    
    function isTooClose(newV, vertices, minDist = MIN_DIST) {
        const minDistSq = minDist ** 2;
        for (const v of vertices) {
            const distSq = (newV.x - v.x) ** 2 + (newV.y - v.y) ** 2;
            if (distSq < minDistSq) {
                return true;
            }
        }
        return false;
    }

    function isTooLinear(p1, p2, p3) {
        const crossProduct = (p2.y - p1.y) * (p3.x - p2.x) - (p3.y - p2.y) * (p2.x - p1.x);
        return Math.abs(crossProduct) < COLLINEARITY_THRESHOLD;
    }
    
    function isTooSharpAngle(p1, p2, p3) {
        const v1x = p1.x - p2.x;
        const v1y = p1.y - p2.y;
        const v2x = p3.x - p2.x;
        const v2y = p3.y - p2.y;

        const dotProduct = v1x * v2x + v1y * v2y;
        
        const mag1 = Math.sqrt(v1x * v1x + v1y * v1y);
        const mag2 = Math.sqrt(v2x * v2x + v2y * v2y);
        
        if (mag1 === 0 || mag2 === 0) return true; 

        const cosine = dotProduct / (mag1 * mag2);
        
        return cosine > MIN_ANGLE_COSINE; 
    }

    function isProblemTooLinear(vertices, newV) {
        const len = vertices.length;
        if (len >= 2) {
            const p1 = vertices[len - 2]; 
            const p2 = vertices[len - 1]; 
            const p3 = newV;             
            return isTooLinear(p1, p2, p3);
        }
        return false;
    }
    
    function isProblemTooSharp(vertices, newV) {
        const len = vertices.length;
        if (len >= 2) {
            const p1 = vertices[len - 2]; 
            const p2 = vertices[len - 1]; 
            const p3 = newV;             
            const isAxisPoint = (p) => p.x === HALF_COUNT || p.y === HALF_COUNT;
            
            if (isAxisPoint(p1) && isAxisPoint(p2) && isAxisPoint(p3)) {
                 return false; 
            }
            
            return isTooSharpAngle(p1, p2, p3);
        }
        return false;
    }
    
    function distSq(p1, p2) {
        return (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;
    }
    
    function calculateSymmetricPoint(v, type) {
        let symX, symY;
        const C = HALF_COUNT;
        if (type === 'line') { 
            symX = 2 * C - v.x; 
            symY = v.y;
        } else if (type === 'point') { 
            symX = 2 * C - v.x; 
            symY = 2 * C - v.y;
        } else {
            return v;
        }
        return { x: Math.round(symX), y: Math.round(symY) };
    }
    
    function createSequentialLines(vertices, close = false) {
        const lines = [];
        if (vertices.length < 2) return lines;
        
        const count = vertices.length;
        for (let i = 0; i < count; i++) {
            const p1 = vertices[i];
            const p2 = vertices[(i + 1) % count];
            
            if (!close && i === count - 1) break; 
            
            lines.push({ p1: p1, p2: p2 });
        }
        return lines;
    }
    
    function findPointSymmetricBoundary(points) {
        if (points.length < 3) return points;
        const C = CENTER_POINT;
        
        points.sort((a, b) => {
            const angleA = Math.atan2(a.y - C.y, a.x - C.x);
            const angleB = Math.atan2(b.y - C.y, b.x - C.x);
            if (Math.abs(angleA - angleB) < 1e-9) {
                return distSq(b, C) - distSq(a, C); 
            }
            return angleA - angleB; 
        });

        let finalBoundary = [];
        let i = 0;
        while (i < points.length) {
            let j = i + 1;
            while (j < points.length && Math.abs(Math.atan2(points[j].y - C.y, points[j].x - C.x) - Math.atan2(points[i].y - C.y, points[i].x - C.x)) < 1e-6) {
                j++;
            }
            finalBoundary.push(points[i]); 
            i = j;
        }
        return finalBoundary;
    }
    
    function getLinesOnOneSide(allLines, angle) {
        const centerX = CENTER_POINT.x;
        const centerY = CENTER_POINT.y;
        const sinAngle = Math.sin(angle);
        const cosAngle = Math.cos(angle);
        const newLines = [];

        allLines.forEach(line => {
            const p1 = line.p1;
            const p2 = line.p2;

            const val1 = (p1.y - centerY) * cosAngle - (p1.x - centerX) * sinAngle;
            const val2 = (p2.y - centerY) * cosAngle - (p2.x - centerX) * sinAngle;

            const onOneSide = val1 >= 0 && val2 >= 0;
            const onOtherSide = val1 < 0 && val2 < 0;

            if (onOneSide) {
                newLines.push(line);
            } else if (!onOneSide && !onOtherSide) {
                const x1 = p1.x;
                const y1 = p1.y;
                const x2 = p2.x;
                const y2 = p2.y;
                
                const slope = (y2 - y1) / (x2 - x1);
                const intercept = y1 - slope * x1;

                let intersectionX, intersectionY;
                const lineSlope = sinAngle / cosAngle;
                const lineIntercept = centerY - lineSlope * centerX;

                if (Math.abs(cosAngle) < 1e-6) {
                    intersectionX = centerX;
                    intersectionY = slope * intersectionX + intercept;
                } else if (Math.abs(x1 - x2) < 1e-6) {
                    intersectionX = x1;
                    intersectionY = lineSlope * intersectionX + lineIntercept;
                } else {
                    intersectionX = (lineIntercept - intercept) / (slope - lineSlope);
                    intersectionY = slope * intersectionX + intercept;
                }
                
                const intersectionPoint = { x: Math.round(intersectionX), y: Math.round(intersectionY) };

                if (val1 >= 0) {
                    newLines.push({ p1: p1, p2: intersectionPoint });
                } else {
                    newLines.push({ p1: p2, p2: intersectionPoint });
                }
            }
        });
        
        return newLines;
    }
    
    function generateRandomPoint(vertices) {
        let newV;
        let success = false;
        let attemptCount = 0;
        const MAX_ATTEMPTS = 100;
        
        while (!success && attemptCount < MAX_ATTEMPTS) {
            let x = getRandomInt(MIN_COORD, MAX_COORD);
            let y = getRandomInt(MIN_COORD, MAX_COORD);
            newV = { x: x, y: y };
            
            if (
                !isSamePoint(newV, CENTER_POINT) && 
                !isTooClose(newV, vertices) && 
                distSq(newV, CENTER_POINT) >= MIN_DIST**2
            ) {
                success = true;
            }
            attemptCount++;
        }
        return success ? newV : null;
    }

    function generateRandomProblem(type) {
        let N;
        if (selectedDifficulty === 1) { 
            N = getRandomInt(3, 4); 
        } else { 
            N = getRandomInt(4, 7); 
        }
        
        const MAX_ATTEMPTS_PER_POINT = 100; 

        if (type === 'line') {
            let y1, y2;
            const axisMaxHalfLength = 6; 
            let halfL, midY;
            let attemptCount = 0;
            
            do {
                midY = getRandomInt(8, 12); 
                halfL = getRandomInt(3, axisMaxHalfLength);
                y1 = midY - halfL;
                y2 = midY + halfL;
                attemptCount++;
            } while (y1 < MIN_COORD || y2 > MAX_COORD || Math.abs(y1 - y2) < 3 || attemptCount > MAX_ATTEMPTS_PER_POINT); 
            
            if (attemptCount === MAX_ATTEMPTS_PER_POINT) return null;

            let axisPoint1 = { x: HALF_COUNT, y: y1 }; 
            let axisPoint2 = { x: HALF_COUNT, y: y2 }; 
            let tempVertices = [];
            tempVertices.push(axisPoint1);

            for (let i = 0; i < N - 2; i++) {
                let newV;
                let success = false;
                attemptCount = 0;
                while (!success && attemptCount < MAX_ATTEMPTS_PER_POINT) {
                    let x = getRandomInt(MIN_COORD, HALF_COUNT - 1); 
                    let y = getRandomInt(axisPoint1.y + 1, axisPoint2.y - 1); 
                    if (y <= axisPoint1.y || y >= axisPoint2.y) {
                         y = getRandomInt(axisPoint1.y + 1, axisPoint2.y - 1); 
                    }
                    newV = { x: x, y: y };
                    if (
                        !isTooClose(newV, tempVertices) && 
                        !isProblemTooLinear(tempVertices, newV) &&
                        !isProblemTooSharp(tempVertices, newV)
                    ) {
                        tempVertices.push(newV);
                        success = true;
                    }
                    attemptCount++;
                }
            }
            tempVertices.push(axisPoint2);
            if(tempVertices.length < 3) return null; 

            const nonAxisPoints_Y = tempVertices.filter(v => v.x !== HALF_COUNT);
            nonAxisPoints_Y.sort((a, b) => a.y - b.y);
            let finalVertices = [axisPoint1, ...nonAxisPoints_Y, axisPoint2];
            finalVertices = finalVertices.filter((v, i, self) => i === self.findIndex((t) => isSamePoint(t, v)));
            if(finalVertices.length < 3) return null; 

            const lastV = finalVertices[finalVertices.length - 1];
            const secondLastV = finalVertices[finalVertices.length - 2];
            const firstV = finalVertices[0];
            if (isTooLinear(secondLastV, lastV, firstV) || isTooSharpAngle(secondLastV, lastV, firstV)) {
                 return null;
            }

            const lines = createSequentialLines(finalVertices, false); 
            const initialLines = lines.filter(line => 
                 line.p1.x <= HALF_COUNT && line.p2.x <= HALF_COUNT
            );
            let initialVertices = [];
            initialLines.forEach(line => {
                if (!initialVertices.some(v => isSamePoint(v, line.p1))) initialVertices.push(line.p1);
                if (!initialVertices.some(v => isSamePoint(v, line.p2))) initialVertices.push(line.p2);
            });
            if (!initialVertices.some(v => isSamePoint(v, axisPoint1))) initialVertices.push(axisPoint1);
            if (!initialVertices.some(v => isSamePoint(v, axisPoint2))) initialVertices.push(axisPoint2);
            
            return { 
                type: 'line', 
                initialVertices: initialVertices, 
                initialLines: initialLines, 
                allVertices: null, 
                allLines: null,
                problemHalfOrder: finalVertices 
            };

        } else if (type === 'point') {
            let initialPoints = [];
            const MAX_ATTEMPTS = 500;
            let attempt = 0;
            let finalVertices = [];
            
            const numPairs = getRandomInt(3, 5);
            const MAX_POINT_ATTEMPTS = 50;
            let generatedPoints = new Set();
            let uniquePoints = [];

            while(uniquePoints.length < numPairs && attempt < MAX_ATTEMPTS) {
                let newV = generateRandomPoint(uniquePoints);
                if(newV) {
                    uniquePoints.push(newV);
                }
                attempt++;
            }
            if (uniquePoints.length < numPairs) return null;

            finalVertices = [...uniquePoints];
            uniquePoints.forEach(v => {
                const symV = calculateSymmetricPoint(v, 'point');
                if (!finalVertices.some(av => isSamePoint(av, symV))) {
                    finalVertices.push(symV);
                }
            });
            
            let sortedVertices = findPointSymmetricBoundary(finalVertices);
            
            for (let i = 0; i < sortedVertices.length; i++) {
                const len = sortedVertices.length;
                const p1 = sortedVertices[(i - 1 + len) % len];
                const p2 = sortedVertices[i];
                const p3 = sortedVertices[(i + 1) % len];
                
                if (isTooLinear(p1, p2, p3) || isTooSharpAngle(p1, p2, p3)) {
                     return null;
                }
            }
            
            const allLines = createSequentialLines(sortedVertices, true);

            const angle = Math.random() * Math.PI; 
            
            const initialLines = getLinesOnOneSide(allLines, angle);
            
            if (initialLines.length < 1) return null;
            
            let initialVertices = [];
            initialLines.forEach(line => {
                if (!initialVertices.some(v => isSamePoint(v, line.p1))) initialVertices.push(line.p1);
                if (!initialVertices.some(v => isSamePoint(v, line.p2))) initialVertices.push(line.p2);
            });

            if (initialVertices.length < 2) return null;

            return {
                type: 'point',
                initialVertices: initialVertices,
                initialLines: initialLines,
                allVertices: sortedVertices,
                allLines: allLines
            };
        }
    }


    // --- 1. ì„¤ì • ë° ì‹œì‘ ---
    function initializeSetupListeners() {
        document.querySelectorAll('#type-select button').forEach(button => {
            button.addEventListener('click', handleTypeSelect);
        });
        document.querySelectorAll('#difficulty-select button').forEach(button => {
            button.addEventListener('click', handleDifficultySelect);
        });
    }

    function handleTypeSelect(event) {
        document.querySelectorAll('#type-select button').forEach(b => b.classList.remove('selected'));
        event.currentTarget.classList.add('selected');
        selectedType = event.currentTarget.getAttribute('data-type');
    }
    
    function handleDifficultySelect(event) {
        document.querySelectorAll('#difficulty-select button').forEach(b => b.classList.remove('selected'));
        event.currentTarget.classList.add('selected');
        selectedDifficulty = parseInt(event.currentTarget.getAttribute('data-difficulty'));
    }

    function changeQuantity(delta) {
        const current = parseInt(document.getElementById('problem-quantity').textContent);
        let newQuantity = current + delta;
        if (newQuantity < 5) newQuantity = 5;
        if (newQuantity > 50) newQuantity = 50;
        document.getElementById('problem-quantity').textContent = newQuantity;
        totalProblems = newQuantity; 
    }

    function startQuiz() {
        const problemsToGenerate = totalProblems;
        problemList = [];
        let generatedVertexStrings = new Set();
        let attempt = 0;
        const MAX_ATTEMPTS = problemsToGenerate * 20; 

        while (problemList.length < problemsToGenerate && attempt < MAX_ATTEMPTS) {
            let type;
            if (selectedType === 'both') {
                type = Math.random() < 0.5 ? 'line' : 'point';
            } else {
                type = selectedType;
            }

            const newProblem = generateRandomProblem(type);
            
            if (!newProblem || newProblem.initialVertices.length < 2) {
                 attempt++;
                 continue;
            }
            
            const vertexString = JSON.stringify(newProblem.initialVertices.map(v => `${v.x},${v.y}`).sort());

            if (!generatedVertexStrings.has(vertexString)) {
                problemList.push(newProblem);
                generatedVertexStrings.add(vertexString);
            }
            attempt++;
        }
        
        totalProblems = problemList.length; 
        
        currentProblem = 0;
        score.isFirstAttempt = true; 
        
        document.getElementById('setup-page').style.display = 'none';
        document.getElementById('problem-page').style.display = 'block';
        
        loadProblem(); 
    }

    function loadProblem() {
        if (currentProblem >= totalProblems) {
            showFinalResult();
            return;
        }

        const currentP = problemList[currentProblem];
        const pType = currentP.type === 'line' ? 'ì„ ëŒ€ì¹­' : 'ì ëŒ€ì¹­';
        
        document.getElementById('problem-number').textContent = `${currentProblem + 1}ë²ˆì§¸ ë¬¸ì œ (ëœë¤)`;
        document.getElementById('problem-instruction').innerHTML = `ì•„ë˜ ë„í˜•ì€ **${pType}**ë„í˜•ì…ë‹ˆë‹¤. ë‚˜ë¨¸ì§€ ë¶€ë¶„ì„ ì™„ì„±í•´ ì£¼ì„¸ìš”. ğŸ“`;
        
        document.getElementById('check-answer-btn').style.display = 'block';
        document.getElementById('next-problem-btn').style.display = 'none';
        document.getElementById('reset-drawing-btn').style.display = 'none';
        score.isFirstAttempt = true; 

        problemVertices = currentP.initialVertices;
        problemLines = currentP.initialLines; 
        userVertices = [];
        userLines = [];
        tempLineStart = null;
        
        setCanvasMode('vertex'); 
        
        clearCanvas(false); 
    }

    function clearCanvas(clearUserDrawing) {
        document.querySelectorAll('.user-dot').forEach(dot => dot.remove());

        if (clearUserDrawing) {
            userVertices = [];
            userLines = [];
            tempLineStart = null;
            redrawCanvas(); 
            setCanvasMode('vertex'); 
            return;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        redrawCanvas();
    }
    
    // --- 2. ìº”ë²„ìŠ¤ ê·¸ë¦¬ê¸° ë° ëª¨ë“œ ì œì–´ ---

    function drawGrid() {
        ctx.strokeStyle = '#333'; 
        ctx.lineWidth = 0.5;
        
        ctx.setLineDash([1, 4]); 
        
        for (let x = 0; x <= canvas.width; x += GRID_SIZE) { 
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); 
        }
        for (let y = 0; y <= canvas.height; y += GRID_SIZE) { 
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); 
        }
        
        ctx.setLineDash([]); 

        // ëŒ€ì¹­ ì¶•/ì  í‘œì‹œ (ë¹¨ê°„ìƒ‰)
        ctx.strokeStyle = '#ff0000'; 
        ctx.lineWidth = 2;
        if (problemList.length > currentProblem && problemList[currentProblem].type === 'line') {
            const centerX = canvas.width / 2;
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.stroke();
        } else if (problemList.length > currentProblem && problemList[currentProblem].type === 'point') {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#ff0000';
            ctx.fill();
        }
    }

    function drawLines(lines, color) {
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        lines.forEach(line => {
            ctx.beginPath();
            ctx.moveTo(line.p1.x * GRID_SIZE, line.p1.y * GRID_SIZE);
            ctx.lineTo(line.p2.x * GRID_SIZE, line.p2.y * GRID_SIZE);
            ctx.stroke();
        });
    }

    function redrawCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height); 
        drawGrid();

        // 1. ë¬¸ì œ ë„í˜• ì™¸ê³½ì„  (íŒŒë€ìƒ‰)
        drawLines(problemLines, '#007bff'); 

        // 2. ì‚¬ìš©ì ì„ ë¶„ (ë…¹ìƒ‰)
        drawLines(userLines, '#28a745'); 

        // 3. ì„ ë¶„ ì‡ê¸° ëª¨ë“œì—ì„œ ì‹œì‘ì ì„ í•˜ì´ë¼ì´íŠ¸
        if (canvasMode === 'line' && tempLineStart) {
              drawDot(tempLineStart.x * GRID_SIZE, tempLineStart.y * GRID_SIZE, '#ff0000', 6);
        }

        renderUserVertices(); 
        
        const canStartLineDrawing = userVertices.length >= 1 || problemVertices.length > 1;
        document.getElementById('mode-line').disabled = !canStartLineDrawing;
    }


    function isVertexOnProblemBoundary(v) {
        return problemVertices.some(pv => isSamePoint(pv, v));
    }


    // --- 3. ì •ë‹µ í™•ì¸ ë° ê²°ê³¼ ---
    
    function checkAnswer() {
        const currentP = problemList[currentProblem];
        const problemType = currentP.type;
        const resultDiv = document.getElementById('result-message');
        
        let verticesAreCorrect = checkVerticesSymmetry(problemType);
        let isLinesCorrect = false;

        if (verticesAreCorrect) {
            if (problemType === 'line') {
                isLinesCorrect = checkLineSymmetryLines(currentP);
            } else if (problemType === 'point') {
                isLinesCorrect = checkPointSymmetryLines(currentP);
            }
        }
        
        if (verticesAreCorrect && isLinesCorrect) {
            resultDiv.textContent = 'ğŸ‰ ì •ë‹µì…ë‹ˆë‹¤! ë„í˜•ì„ ì™„ë²½í•˜ê²Œ ì™„ì„±í–ˆì–´ìš”! ğŸ‰';
            resultDiv.className = 'correct';
            
            if (score.isFirstAttempt) { score.correct++; } else { score.retried++; }
            score.totalAttempted++;

            document.getElementById('check-answer-btn').style.display = 'none';
            document.getElementById('next-problem-btn').style.display = 'block';
            document.getElementById('reset-drawing-btn').style.display = 'none';

        } else {
            let failReason = 'ë‹¤ì‹œ ìƒê°í•´ ë³¼ê¹Œìš”? ';
            
            if (!verticesAreCorrect) {
                 failReason += 'ê¼­ì§“ì ì˜ ìœ„ì¹˜ë‚˜ ê°œìˆ˜ê°€ ì˜ëª»ë˜ì—ˆì–´ìš”. ëª¨ë“  ê¼­ì§“ì ì´ ëŒ€ì¹­ ì§ì„ ì´ë£¨ëŠ”ì§€ í™•ì¸í•´ ì£¼ì„¸ìš”.';
            } else if (!isLinesCorrect) {
                 failReason += 'ì„ ë¶„ ì‡ê¸°(2ë‹¨ê³„)ë¥¼ í†µí•´ ì™„ì„±ëœ ë„í˜•ì´ **ëŒ€ì¹­ì„ ì´ë£¨ì§€ ì•Šê±°ë‚˜** í•„ìš”í•œ ëª¨ë“  ì„ ë¶„ì„ ë¹ ëœ¨ë ¸ì–´ìš”. ì„ ë¶„ ì—°ê²° ì˜¤ë¥˜ë¥¼ í™•ì¸í•´ ì£¼ì„¸ìš”.';
            } else {
                 failReason += 'ê¼­ì§“ì ì´ë‚˜ ì„ ë¶„ ì—°ê²°ì— ì˜¤ë¥˜ê°€ ìˆì–´ ëŒ€ì¹­ë„í˜•ì´ ì™„ì„±ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.';
            }

            resultDiv.textContent = `ğŸ¤” ${failReason}`;
            resultDiv.className = 'incorrect';
            score.isFirstAttempt = false;
            
            document.getElementById('check-answer-btn').style.display = 'block';
            document.getElementById('next-problem-btn').style.display = 'none';
            document.getElementById('reset-drawing-btn').style.display = 'block'; 
        }
        
        resultDiv.style.display = 'block';
    }

    function checkVerticesSymmetry(problemType) {
        const allProblemAndUserVerticesSet = new Map();
        [...problemVertices, ...userVertices].forEach(v => {
            const key = `${Math.round(v.x)},${Math.round(v.y)}`;
            if (!allProblemAndUserVerticesSet.has(key)) {
                allProblemAndUserVerticesSet.set(key, { x: Math.round(v.x), y: Math.round(v.y) });
            }
        });
        const finalVertices = Array.from(allProblemAndUserVerticesSet.values());
        
        const numVertices = finalVertices.length;
        const includesCenter = finalVertices.some(v => isSamePoint(v, CENTER_POINT));
        
        if (problemType === 'line') {
            const boundaryVerticesCount = problemVertices.filter(v => v.x === HALF_COUNT).length;
            if (numVertices % 2 !== 0 && boundaryVerticesCount < 2) return false;
        } else if (problemType === 'point') {
             if (includesCenter) {
                if (numVertices % 2 === 0) return false; 
            } else {
                if (numVertices % 2 !== 0) return false;
            }
        }
       
        let symmetricPairs = new Map();
        for (const v of finalVertices) {
            if (isSamePoint(v, CENTER_POINT)) continue;
            const key = `${v.x},${v.y}`;
            if (symmetricPairs.has(key)) continue;

            const symmetricV = calculateSymmetricPoint(v, problemType);
            const symmetricExists = finalVertices.some(av => isSamePoint(av, symmetricV));

            if (!symmetricExists) return false;
            
            symmetricPairs.set(key, true);
            symmetricPairs.set(`${symmetricV.x},${symmetricV.y}`, true);
        }
        return true;
    }
    
    // V78: ì„ ëŒ€ì¹­ ì„ ë¶„ ê²€ì¦ ë¡œì§ ê°œì„ 
    function checkLineSymmetryLines(currentP) {
        const submittedLines = userLines;
        const problemLines = currentP.initialLines;
        
        const problemSymmetricLines = problemLines.map(line => ({
            p1: calculateSymmetricPoint(line.p1, 'line'),
            p2: calculateSymmetricPoint(line.p2, 'line')
        }));
        
        const submittedLinesMap = new Map();
        submittedLines.forEach(line => {
            const normalizedLine = isSameLine(line, line) ? line : {p1:line.p2, p2:line.p1};
            submittedLinesMap.set(JSON.stringify(normalizedLine), normalizedLine);
        });

        if (submittedLines.length !== problemSymmetricLines.length) return false;

        let allMatched = true;
        for (const line of problemSymmetricLines) {
            const normalizedLine = isSameLine(line, line) ? line : {p1:line.p2, p2:line.p1};
            if(!submittedLinesMap.has(JSON.stringify(normalizedLine))){
                 allMatched = false;
                 break;
            }
        }
        return allMatched;
    }
    
    // V78: ì ëŒ€ì¹­ ì„ ë¶„ ê²€ì¦ ë¡œì§ ê°œì„ 
    function checkPointSymmetryLines(currentP) {
        const submittedLines = userLines;
        const problemLines = currentP.initialLines;

        const problemSymmetricLines = problemLines.map(line => ({
            p1: calculateSymmetricPoint(line.p1, 'point'),
            p2: calculateSymmetricPoint(line.p2, 'point')
        }));

        const totalProblemLines = [...problemLines, ...problemSymmetricLines];
        
        const totalProblemLinesMap = new Map();
        totalProblemLines.forEach(line => {
            const normalizedLine = isSameLine(line, line) ? line : {p1:line.p2, p2:line.p1};
            totalProblemLinesMap.set(JSON.stringify(normalizedLine), normalizedLine);
        });

        if (submittedLines.length !== totalProblemLines.length / 2) return false;

        let allMatched = true;
        submittedLines.forEach(line => {
             const normalizedLine = isSameLine(line, line) ? line : {p1:line.p2, p2:line.p1};
            const symLine = {
                p1: calculateSymmetricPoint(line.p1, 'point'),
                p2: calculateSymmetricPoint(line.p2, 'point')
            };
            const normalizedSymLine = isSameLine(symLine, symLine) ? symLine : {p1:symLine.p2, p2:symLine.p1};

            if (!totalProblemLinesMap.has(JSON.stringify(normalizedLine)) && !totalProblemLinesMap.has(JSON.stringify(normalizedSymLine))) {
                allMatched = false;
            }
        });
        
        return allMatched;
    }
    
    function findClosestValidLinePoint(v) {
        const allTargetVertices = [
            ...problemVertices, 
            ...userVertices
        ];
        
        if (problemList.length > currentProblem && problemList[currentProblem].type === 'point') {
             allTargetVertices.push(CENTER_POINT);
        }

        let closestPoint = null;
        let minDistSq = Infinity;

        for (const p of allTargetVertices) {
            const dist = distSq(v, p);
            if (dist < minDistSq) {
                minDistSq = dist;
                closestPoint = p;
            }
        }
        return closestPoint;
    }
    
    function setCanvasMode(mode) {
        canvasMode = mode;
        const vertexBtn = document.getElementById('mode-vertex');
        const lineBtn = document.getElementById('mode-line');

        vertexBtn.classList.remove('mode-btn-active');
        lineBtn.classList.remove('mode-btn-active');
        
        const canStartLineDrawing = userVertices.length >= 1 || problemVertices.length > 1; 

        if (mode === 'vertex') {
            vertexBtn.classList.add('mode-btn-active');
            canvas.style.cursor = 'crosshair';
            tempLineStart = null;
        } else { // 'line' mode
            lineBtn.classList.add('mode-btn-active');
            canvas.style.cursor = 'pointer';
            vertexBtn.disabled = false;
        }
        
        document.getElementById('mode-line').disabled = !canStartLineDrawing;
        redrawCanvas();
    }
    
    function renderUserVertices() {
        document.querySelectorAll('.user-dot').forEach(dot => dot.remove());
        userVertices.forEach((v) => {
            const dot = document.createElement('div');
            dot.className = 'user-dot';
            dot.style.left = `${v.x * GRID_SIZE}px`;
            dot.style.top = `${v.y * GRID_SIZE}px`;
            canvasWrapper.appendChild(dot);
        });
    }

    function showFinalResult() {
        document.getElementById('problem-page').style.display = 'none';
        document.getElementById('final-result-page').style.display = 'block';
        
        const total = totalProblems;
        const accuracy = total > 0 ? ((score.correct / total) * 100).toFixed(1) : 0;

        document.getElementById('correct-count').textContent = score.correct;
        document.getElementById('retried-count').textContent = score.retried; 
        document.getElementById('final-accuracy').textContent = `${accuracy}%`;
    }

    window.onload = () => {
        document.getElementById('problem-quantity').textContent = totalProblems;
        canvasWrapper.style.width = `${canvas.width}px`;
        canvasWrapper.style.height = `${canvas.height}px`;
        document.getElementById('mode-line').disabled = true;
        
        initializeSetupListeners(); 
        
        canvas.addEventListener('click', (event) => {
            if (document.getElementById('check-answer-btn').style.display === 'none' && document.getElementById('next-problem-btn').style.display === 'block') return;

            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const gridX = Math.round(x / GRID_SIZE);
            const gridY = Math.round(y / GRID_SIZE);
            if (gridX < 0 || gridX > GRID_COUNT || gridY < 0 || gridY > GRID_COUNT) return;

            const clickedGridPoint = { x: gridX, y: gridY };

            if (canvasMode === 'vertex') {
                const currentP = problemList[currentProblem];
                const pType = currentP ? currentP.type : 'line'; 
                
                if (isVertexOnProblemBoundary(clickedGridPoint) || (pType === 'point' && isSamePoint(clickedGridPoint, CENTER_POINT))) {
                    return;
                }
                
                if (pType === 'line' && clickedGridPoint.x === HALF_COUNT && !isVertexOnProblemBoundary(clickedGridPoint)) {
                      return;
                }

                const existingIndex = userVertices.findIndex(v => isSamePoint(v, clickedGridPoint));
                if (existingIndex > -1) {
                    userVertices.splice(existingIndex, 1);
                    userLines = userLines.filter(line => 
                        !(isSamePoint(line.p1, clickedGridPoint) || isSamePoint(line.p2, clickedGridPoint))
                    );
                } else {
                    userVertices.push(clickedGridPoint);
                }
                redrawCanvas();

            } else if (canvasMode === 'line') {
                const targetPoint = findClosestValidLinePoint(clickedGridPoint); 

                if (!targetPoint) {
                    return;
                }

                if (!tempLineStart) {
                    tempLineStart = targetPoint;
                    redrawCanvas(); 
                } else {
                    if (isSamePoint(tempLineStart, targetPoint)) {
                        tempLineStart = null; 
                    } else {
                        const newLine = { p1: tempLineStart, p2: targetPoint };
                        if (!isLineExists(newLine)) {
                            userLines.push(newLine);
                        } else {
                            userLines = userLines.filter(existingLine => !isSameLine(existingLine, newLine));
                        }
                        tempLineStart = null; 
                    }
                    redrawCanvas();
                }
            }
        });

        document.getElementById('start-quiz-btn').addEventListener('click', startQuiz);
        document.getElementById('next-problem-btn').addEventListener('click', nextProblem);
        
        document.getElementById('reset-drawing-btn').addEventListener('click', () => clearCanvas(true));
        document.getElementById('clear-canvas-btn').addEventListener('click', () => clearCanvas(true));

        document.getElementById('quantity-minus-5').addEventListener('click', () => changeQuantity(-5));
        document.getElementById('quantity-plus-5').addEventListener('click', () => changeQuantity(5));


        document.getElementById('setup-page').style.display = 'flex';
    };
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="ko">
<head>
Â  Â  <meta charset="UTF-8">
Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
Â  Â  <title>ì„ ëŒ€ì¹­/ì ëŒ€ì¹­ë„í˜• ì™„ì „ ì •ë³µ</title>
Â  Â  <meta property="og:title" content="ì„ ëŒ€ì¹­/ì ëŒ€ì¹­ë„í˜• ì™„ì „ ì •ë³µ">
Â  Â  <meta property="og:description" content="ì„ ëŒ€ì¹­, ì ëŒ€ì¹­ë„í˜• ë¬¸ì œë¥¼ ì—°ìŠµí•´ë³´ì„¸ìš”!">
Â  Â  <meta property="og:image" content="https://3arch2nd.github.io/symmetry/thumb.png">
Â  Â  <meta property="og:url" content="https://3arch2nd.github.io/symmetry/">
Â  Â  <meta property="og:type" content="website">
Â  Â  <link rel="preconnect" href="https://fonts.googleapis.com">
Â  Â  <link rel="preconnect" href="https://fonts.googleapis.com">
Â  Â  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
Â  Â  <link href="https://fonts.googleapis.com/css2?family=Gowun+Dodum&display=swap" rel="stylesheet">
Â  Â  <style>
/* ê¸°ë³¸ ìŠ¤íƒ€ì¼ */
body {
Â  Â  font-family: 'Gowun Dodum', sans-serif;
Â  Â  display: flex;
Â  Â  flex-direction: column;
Â  Â  justify-content: center;
Â  Â  align-items: center;
Â  Â  min-height: 100vh;
Â  Â  margin: 0;
Â  Â  background-color: #f4f7f6;
Â  Â  color: #333;
Â  Â  text-align: center;
}
.container {
Â  Â  position: relative;
Â  Â  background-color: white;
Â  Â  padding: 30px;
Â  Â  border-radius: 12px;
Â  Â  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
Â  Â  width: 90%;
Â  Â  max-width: 760px;
Â  Â  text-align: center;
Â  Â  margin: 20px auto;
Â  Â  box-sizing: border-box;
}
h1 {
Â  Â  color: #4b8134;
Â  Â  margin-bottom: 20px;
Â  Â  font-size: 2em;
}
h2 {
Â  Â  margin-bottom: 5px;
}
small {
Â  Â  display: block;
Â  Â  font-size: 18px;
Â  Â  color: #6c757d;
Â  Â  margin-bottom: 20px;
Â  Â  line-height: 1.5;
}
button {
Â  Â  font-family: 'Gowun Dodum', sans-serif;
Â  Â  padding: 10px 20px;
Â  Â  margin: 5px;
Â  Â  border: none;
Â  Â  border-radius: 8px;
Â  Â  cursor: pointer;
Â  Â  font-size: 16px;
Â  Â  transition: background-color 0.3s, transform 0.1s;
}
button:hover {
Â  Â  transform: translateY(-1px);
}
.primary-btn {
Â  Â  background-color: #a0c179;
Â  Â  color: white;
}
.primary-btn:hover {
Â  Â  background-color: #8cb24b;
}
.secondary-btn {
Â  Â  background-color: #e9e9e9;
Â  Â  color: #333;
Â  Â  border: none;
}
.secondary-btn:hover {
Â  Â  background-color: #d9d9d9;
}
#clear-canvas-btn {
Â  Â  background-color: #e06666;
Â  Â  color: white;
}
#clear-canvas-btn:hover {
Â  Â  background-color: #cc4125;
}
.mode-btn-active {
Â  Â  background-color: #ffc107;
Â  Â  color: #333;
Â  Â  font-weight: bold;
}
#mode-selection-page, #setup-page, #problem-page, #final-result-page {
Â  Â  display: none;
}
#mode-selection-page {
Â  Â  display: flex;
Â  Â  flex-direction: column;
Â  Â  justify-content: center;
Â  Â  align-items: center;
Â  Â  gap: 20px;
}
.mode-buttons {
Â  Â  display: flex;
Â  Â  gap: 15px;
Â  Â  margin-top: 20px;
Â  Â  width: 100%;
Â  Â  justify-content: space-around;
}
.mode-buttons button {
Â  Â  padding: 20px 30px;
Â  Â  font-size: 20px; /* [ìˆ˜ì •] PC ê¸°ë³¸ í°íŠ¸ í¬ê¸° ì¦ê°€ */
Â  Â  width: 100%;
Â  Â  max-width: 250px;
}

#classic-mode-btn {
Â  Â  background-color: #ffc107;
Â  Â  color: #333;
Â  Â  font-weight: bold;
}
#classic-mode-btn:hover {
Â  Â  background-color: #fdb827;
}
#time-attack-mode-btn {
Â  Â  background-color: #e06666;
Â  Â  color: white;
Â  Â  font-weight: bold;
}
#time-attack-mode-btn:hover {
Â  Â  background-color: #cc4125;
}


.mode-option {
Â  Â  display: flex;
Â  Â  flex-direction: column;
Â  Â  align-items: center;
Â  Â  gap: 10px;
Â  Â  flex: 1;
}
.mode-description {
Â  Â  font-size: 16px;
Â  Â  color: #6c757d;
Â  Â  line-height: 1.5;
}

#setup-page {
Â  Â  display: flex;
Â  Â  flex-direction: column;
Â  Â  gap: 20px;
}
.setting-group {
Â  Â  border: 1px solid #ddd;
Â  Â  padding: 15px;
Â  Â  border-radius: 8px;
Â  Â  text-align: center;
Â  Â  display: flex;
Â  Â  flex-direction: column;
Â  Â  justify-content: center;
Â  Â  align-items: center;
Â  Â  box-sizing: border-box;
Â  Â  flex-grow: 1;
}
.option-buttons {
Â  Â  display: flex;
Â  Â  flex-direction: row;
Â  Â  justify-content: center;
Â  Â  gap: 5px;
Â  Â  margin-top: 10px;
}
.option-buttons button {
Â  Â  flex-grow: 1;
Â  Â  padding: 10px 20px;
}
.option-buttons button.selected {
Â  Â  background-color: #ffc107;
Â  Â  color: #333;
Â  Â  font-weight: bold;
}
.canvas-wrapper {
Â  Â  position: relative;
Â  Â  display: block;
Â  Â  margin: 0 auto 20px auto;
Â  Â  width: 100%;
Â  Â  max-width: 400px;
Â  Â  height: auto;
Â  Â  aspect-ratio: 1 / 1;
Â  Â  border: 2px solid #333;
Â  Â  box-sizing: border-box;
}
#grid-canvas {
Â  Â  background-color: white;
Â  Â  cursor: crosshair;
Â  Â  width: 100%;
Â  Â  height: 100%;
Â  Â  display: block;
Â  Â  -webkit-tap-highlight-color: transparent;
}
.user-dot {
Â  Â  width: 8px;
Â  Â  height: 8px;
Â  Â  background-color: #dc3545;
Â  Â  border-radius: 50%;
Â  Â  position: absolute;
Â  Â  transform: translate(-50%, -50%);
Â  Â  pointer-events: none;
Â  Â  box-shadow: 0 0 3px rgba(0,0,0,0.5);
Â  Â  z-index: 10;
}
.problem-dot, .line-dot {
Â  Â  width: 8px;
Â  Â  height: 8px;
Â  Â  background-color: black;
Â  Â  border-radius: 50%;
Â  Â  position: absolute;
Â  Â  transform: translate(-50%, -50%);
Â  Â  pointer-events: none;
Â  Â  box-shadow: 0 0 3px rgba(0,0,0,0.5);
Â  Â  z-index: 10;
}
.selected-line-dot {
Â  Â  width: 10px;
Â  Â  height: 10px;
Â  Â  background-color: #ff0000;
Â  Â  border-radius: 50%;
Â  Â  position: absolute;
Â  Â  transform: translate(-50%, -50%);
Â  Â  pointer-events: none;
Â  Â  box-shadow: 0 0 5px rgba(255,0,0,0.8);
Â  Â  z-index: 11;
}
.canvas-controls {
Â  Â  display: flex;
Â  Â  flex-wrap: wrap;
Â  Â  justify-content: center;
Â  Â  gap: 10px;
Â  Â  margin-bottom: 20px;
}
.correct, .incorrect {
Â  Â  padding: 10px;
Â  Â  border-radius: 8px;
Â  Â  font-weight: bold;
Â  Â  margin-top: 15px;
}
.correct { color: #28a745; }
.incorrect { color: #dc3545; }
#quantity-control, #time-control {
Â  Â  display: flex;
Â  Â  align-items: center;
Â  Â  justify-content: center;
Â  Â  gap: 15px;
}
#quantity-control button, #time-control button {
Â  Â  width: 30px;
Â  Â  height: 30px;
Â  Â  border-radius: 50%;
Â  Â  padding: 0;
Â  Â  margin: 0;
Â  Â  font-size: 20px;
Â  Â  font-weight: bold;
Â  Â  line-height: 30px;
Â  Â  background-color: #f0f0f0;
Â  Â  border: 1px solid #ccc;
Â  Â  color: #333;
}
#quantity-control button:hover, #time-control button:hover {
Â  Â  background-color: #e0e0e0;
}
.quantity-display {
Â  Â  display: inline-block;
Â  Â  width: auto;
Â  Â  min-width: 40px;
Â  Â  height: auto;
Â  Â  background-color: transparent;
Â  Â  border-radius: 0;
Â  Â  font-size: 24px;
Â  Â  font-weight: bold;
Â  Â  color: #333;
Â  Â  box-shadow: none;
Â  Â  vertical-align: baseline;
Â  Â  margin: 0;
Â  Â  text-align: center;
}
.footer {
Â  Â  margin-top: 20px;
Â  Â  font-size: 12px;
Â  Â  color: #ccc;
Â  Â  text-align: center;
}
.main-layout {
Â  Â  display: flex;
Â  Â  flex-direction: row;
Â  Â  gap: 20px;
Â  Â  width: 100%;
Â  Â  max-width: 800px;
Â  Â  align-items: stretch;
Â  Â  flex-wrap: wrap;
}
.main-layout h3 {
Â  Â  text-align: center;
}
.left-panel {
Â  Â  flex: 2;
Â  Â  display: flex;
Â  Â  flex-direction: column;
Â  Â  gap: 20px;
}
.right-panel {
Â  Â  flex: 1;
Â  Â  display: flex;
Â  Â  flex-direction: column;
Â  Â  gap: 20px;
}
.settings-wrapper {
Â  Â  position: relative;
Â  Â  flex-grow: 1;
}
.right-panel .setting-group, .left-panel .setting-group {
Â  Â  flex-grow: 1;
}
#start-quiz-btn {
Â  Â  width: 100px;
Â  Â  height: 100px;
Â  Â  border-radius: 50%;
Â  Â  font-size: 20px;
Â  Â  font-weight: bold;
Â  Â  display: flex;
Â  Â  justify-content: center;
Â  Â  align-items: center;
Â  Â  padding: 0;
Â  Â  flex-shrink: 0;
}
.setting-group.start-btn-container {
Â  Â  border: none;
Â  Â  background-color: transparent;
Â  Â  padding: 0;
}
#settings-overlay {
Â  Â  position: absolute;
Â  Â  top: 0;
Â  Â  left: 0;
Â  Â  width: 100%;
Â  Â  height: 100%;
Â  Â  background-color: rgba(0, 0, 0, 0.6);
Â  Â  color: white;
Â  Â  display: flex;
Â  Â  justify-content: center;
Â  Â  align-items: center;
Â  Â  text-align: center;
Â  Â  border-radius: 8px;
Â  Â  z-index: 10;
Â  Â  padding: 10px;
Â  Â  box-sizing: border-box;
Â  Â  font-size: 1.1em;
Â  Â  font-weight: bold;
Â  Â  line-height: 1.5;
}
.problem-header {
Â  Â  display: flex;
Â  Â  justify-content: space-between;
Â  Â  align-items: center;
Â  Â  width: 100%;
}
.home-button {
Â  Â  background-color: #e9e9e9;
Â  Â  color: #333;
Â  Â  border-radius: 8px;
Â  Â  padding: 8px 12px;
Â  Â  font-size: 14px;
Â  Â  display: flex;
Â  Â  align-items: center;
Â  Â  gap: 5px;
Â  Â  cursor: pointer;
Â  Â  text-decoration: none;
Â  Â  transition: background-color 0.3s;
}
.home-button:hover {
Â  Â  background-color: #d9d9d9;
}
#problem-number {
Â  Â  flex-grow: 1;
Â  Â  text-align: center;
Â  Â  margin: 0;
}
#timer-display {
Â  Â  width: 120px;
Â  Â  font-size: 1.2em;
Â  Â  font-weight: bold;
Â  Â  text-align: right;
Â  Â  padding-right: 10px;
Â  Â  color: #333;
Â  Â  display: none;
}
#problem-counter-display {
Â  Â  width: 120px;
Â  Â  font-size: 1em; /* ê¸€ì í¬ê¸°ë¥¼ 1.2emì—ì„œ 1emìœ¼ë¡œ ì¤„ì˜€ìŠµë‹ˆë‹¤. */
Â  Â  font-weight: bold;
Â  Â  text-align: right;
Â  Â  padding-right: 10px;
Â  Â  color: #888;
Â  Â  display: none;
}
#timer-display.time-warning {
Â  Â  color: #dc3545;
Â  Â  animation: pulse 1s infinite;
}
@keyframes pulse {
Â  Â  0% { transform: scale(1); }
Â  Â  50% { transform: scale(1.05); }
Â  Â  100% { transform: scale(1); }
}
.problem-footer {
Â  Â  display: flex;
Â  Â  justify-content: center;
Â  Â  align-items: center;
Â  Â  width: 100%;
Â  Â  margin-top: 20px;
}
#check-answer-btn {
Â  Â  position: relative;
Â  Â  overflow: hidden;
Â  Â  -webkit-user-select: none;
Â  Â  -moz-user-select: none;
Â  Â  -ms-user-select: none;
Â  Â  user-select: none;
Â  Â  background-color: white;
Â  Â  color: black;
Â  Â  border: 2px solid #999;
}
#check-answer-btn:hover {
Â  Â  background-color: #f0f0f0;
}

#check-answer-btn, #next-problem-btn {
Â  Â  min-width: 180px;
}

#next-problem-btn {
Â  Â  border: 2px solid transparent;
}

#check-answer-btn .progress-bar {
Â  Â  position: absolute;
Â  Â  top: 0;
Â  Â  left: 0;
Â  Â  width: 100%;
Â  Â  height: 100%;
Â  Â  background-color: #a0c179;
Â  Â  transform: translateX(-100%);
}
#check-answer-btn .button-text {
Â  Â  position: relative;
Â  Â  z-index: 1;
}

#check-answer-container {
Â  Â  display: flex;
Â  Â  flex-direction: column;
Â  Â  align-items: center;
}
.check-answer-guide {
Â  Â  font-size: 0.8em;
Â  Â  color: #888;
Â  Â  margin-top: 8px;
Â  Â  transition: color 0.3s ease;
}

.popup-overlay {
Â  Â  position: fixed;
Â  Â  top: 0;
Â  Â  left: 0;
Â  Â  width: 100%;
Â  Â  height: 100%;
Â  Â  display: flex;
Â  Â  justify-content: center;
Â  Â  align-items: center;
Â  Â  z-index: 100;
}
.popup-box {
Â  Â  background-color: white;
Â  Â  padding: 30px;
Â  Â  border-radius: 12px;
Â  Â  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
Â  Â  position: relative;
Â  Â  width: 80%;
Â  Â  max-width: 450px;
Â  Â  text-align: center;
Â  Â  display: flex;
Â  Â  flex-direction: column;
Â  Â  align-items: center;
}
.popup-box .close-btn {
Â  Â  position: absolute;
Â  Â  top: 10px;
Â  Â  right: 15px;
Â  Â  font-size: 28px;
Â  Â  font-weight: bold;
Â  Â  color: #333;
Â  Â  cursor: pointer;
Â  Â  background: none;
Â  Â  border: none;
Â  Â  padding: 0;
}
.popup-box .close-btn:hover { color: #6c757d; }
.result-popup #popup-main-message {
Â  Â  font-size: 1.2em;
Â  Â  font-weight: bold;
Â  Â  margin-bottom: 0;
Â  Â  line-height: 1.5;
}
.result-popup #popup-detail-message { display: none; }
.result-popup #popup-next-btn { margin-top: 20px; }
.final-result-layout {
Â  Â  display: flex;
Â  Â  flex-direction: row;
Â  Â  justify-content: space-around;
Â  Â  align-items: center;
Â  Â  margin: 30px 0;
Â  Â  gap: 20px;
}
.result-left, .result-right {
Â  Â  flex: 1;
Â  Â  padding: 20px;
}
.result-left {
Â  Â  border-right: 1px solid #ddd;
}
.result-right p {
Â  Â  font-size: 1.1em;
Â  Â  margin: 15px 0;
}
#final-accuracy {
Â  Â  font-size: 4em;
Â  Â  font-weight: bold;
Â  Â  color: #4b8134;
Â  Â  margin-top: 10px;
}
.score-display {
Â  Â  margin-top: 20px;
Â  Â  font-size: 1.1em;
Â  Â  font-weight: bold;
}
#final-score {
Â  Â  font-size: 1.4em;
Â  Â  font-weight: bold;
Â  Â  color: #4b8134;
Â  Â  display: inline-block;
Â  Â  margin-left: 5px;
}
.result-buttons {
Â  Â  display: flex;
Â  Â  justify-content: center;
Â  Â  align-items: center;
Â  Â  gap: 10px;
Â  Â  margin-top: 20px;
Â  Â  flex-wrap: wrap;
}
#qr-code-btn {
Â  Â  position: absolute;
Â  Â  top: 15px;
Â  Â  right: 15px;
Â  Â  padding: 5px 10px;
Â  Â  font-size: 14px;
Â  Â  z-index: 20;
}
#qr-popup-overlay {
Â  Â  position: fixed;
Â  Â  top: 0;
Â  Â  left: 0;
Â  Â  width: 100%;
Â  Â  height: 100%;
Â  Â  background-color: rgba(255, 255, 255, 0.8);
Â  Â  display: flex;
Â  Â  justify-content: center;
Â  Â  align-items: center;
Â  Â  z-index: 200;
}
.popup-qr {
Â  Â  background-color: white;
Â  Â  padding: 40px;
Â  Â  border-radius: 12px;
Â  Â  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
Â  Â  position: relative;
Â  Â  text-align: center;
}
.popup-qr img {
Â  Â  max-width: 180px;
Â  Â  height: auto;
}
.popup-qr p {
Â  Â  margin-top: 15px;
Â  Â  color: #666;
}
.close-btn-qr {
Â  Â  position: absolute;
Â  Â  top: 10px;
Â  Â  right: 15px;
Â  Â  font-size: 28px;
Â  Â  font-weight: bold;
Â  Â  color: #333;
Â  Â  cursor: pointer;
Â  Â  background: none;
Â  Â  border: none;
Â  Â  padding: 0;
}
#hof-popup-overlay { background-color: rgba(0, 0, 0, 0.2); }
.popup-hof { max-width: 700px; }
.hof-input-group { margin: 20px 0; }
.hof-input-group input {
Â  Â  font-family: 'Gowun Dodum', sans-serif;
Â  Â  font-size: 18px;
Â  Â  padding: 8px;
Â  Â  width: 80px;
Â  Â  text-align: center;
Â  Â  border: 1px solid #ccc;
Â  Â  border-radius: 4px;
Â  Â  margin-right: 10px;
Â  Â  text-transform: uppercase;
}
.hof-columns {
Â  Â  display: flex;
Â  Â  gap: 20px;
Â  Â  width: 100%;
}
.hof-column {
Â  Â  flex: 1;
}
.hof-column h3 {
Â  Â  margin-top: 0;
}
.hof-table-container { max-height: 300px; overflow-y: auto; margin-top: 20px;}
#hof-table-classic, #hof-table-timeattack { width: 100%; border-collapse: collapse; }
#hof-table-classic th, #hof-table-classic td,
#hof-table-timeattack th, #hof-table-timeattack td { padding: 8px; border-bottom: 1px solid #eee; }
#hof-table-classic th, #hof-table-timeattack th { background-color: #f8f9fa; }

.confirm-clear-popup p {
Â  Â  font-size: 1.1em;
Â  Â  margin-bottom: 25px;
Â  Â  line-height: 1.6;
}
.confirm-buttons {
Â  Â  display: flex;
Â  Â  justify-content: center;
Â  Â  gap: 15px;
Â  Â  width: 100%;
}
.confirm-buttons button {
Â  Â  padding: 10px 30px;
Â  Â  font-weight: bold;
}
#confirm-clear-yes-btn {
Â  Â  background-color: #e06666;
Â  Â  color: white;
}
#confirm-clear-yes-btn:hover {
Â  Â  background-color: #cc4125;
}
.mobile-title, .mobile-home { display: none; }


/* ğŸ’»ğŸ“± ë°˜ì‘í˜• ì›¹ ë””ìì¸ (ëª¨ë°”ì¼ ìµœì í™”) ğŸ“±ğŸ’» */
@media (max-width: 768px) {
Â  Â  .main-layout { flex-direction: column; }
Â  Â Â 
Â  Â  .left-panel {Â 
Â  Â  Â  Â  flex-direction: row;Â 
Â  Â  Â  Â  gap: 10px;
Â  Â  Â  Â  margin-top: 0;
Â  Â  }

Â  Â  .right-panel {Â 
Â  Â  Â  Â  width: 100%;Â 
Â  Â  Â  Â  margin-top: 20px;Â 
Â  Â  }
Â  Â Â 
Â  Â  .option-buttons { flex-direction: column; }
Â  Â  .problem-footer { justify-content: center; }
Â  Â  .final-result-layout { flex-direction: column; }
Â  Â  .result-left { border-right: none; border-bottom: 1px solid #ddd; width: 100%; }
Â  Â  .hof-columns { flex-direction: column; }
}

@media (max-width: 480px) {
Â  Â  .container {
Â  Â  Â  Â  padding: 15px;
Â  Â  }
Â  Â Â 
Â  Â  h1 { font-size: 1.6em; }
Â  Â  h2 { font-size: 1.2em; }
Â  Â  small { font-size: 16px; line-height: 1.4; }

Â  Â  #mode-selection-page h1,Â 
Â  Â  #setup-page h1 {
Â  Â  Â  Â  padding-top: 30px;
Â  Â  Â  Â  margin-bottom: 10px;
Â  Â  }

Â  Â  #mode-selection-page {
Â  Â  Â  Â  gap: 10px;
Â  Â  }
Â  Â  #mode-selection-page h2 {
Â  Â  Â  Â  margin-bottom: 10px;
Â  Â  }
Â  Â  .mode-buttons {
Â  Â  Â  Â  margin-top: 10px;
Â  Â  }
Â  Â  .mode-buttons button {
Â  Â  Â  Â  padding: 15px 10px;
Â  Â  Â  Â  font-size: 1.3em;
Â  Â  Â  Â  line-height: 1.3;
Â  Â  }
Â  Â  /* [ì¶”ê°€] ëª¨ë°”ì¼ì—ì„œë§Œ 'ëª¨ë“œ' ê¸€ìê°€ ì¤„ë°”ê¿ˆë˜ë„ë¡ í•©ë‹ˆë‹¤. */
Â  Â  .mode-buttons button span {
Â  Â  Â  Â  display: block;
Â  Â  }
Â  Â  .mode-description {
Â  Â  Â  Â  font-size: 14px;
Â  Â  }

Â  Â  .desktop-title { display: none; }
Â  Â  .mobile-title { display: inline; }
Â  Â  .desktop-home { display: none; }
Â  Â  .mobile-home { display: inline; }
Â  Â  .home-button { padding: 8px 10px; }
Â  Â  #back-to-mode-select-btn {
Â  Â  Â  Â  top: 10px !important;
Â  Â  Â  Â  left: 10px !important;
Â  Â  }
}
</style>
</head>
<body>

<div class="container">
Â  Â  <button id="qr-code-btn" class="secondary-btn">QR ì½”ë“œ</button>
Â  Â Â 
Â  Â  <div id="mode-selection-page">
Â  Â  Â  Â  <h1>
Â  Â  Â  Â  Â  Â  <span class="desktop-title">ì„ ëŒ€ì¹­/ì ëŒ€ì¹­ë„í˜• ì™„ì „ ì •ë³µ</span>
Â  Â  Â  Â  Â  Â  <span class="mobile-title">ì„ ëŒ€ì¹­/ì ëŒ€ì¹­ë„í˜•<br>ì™„ì „ ì •ë³µ</span>
Â  Â  Â  Â  </h1>
Â  Â  Â  Â  <h2>ëª¨ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”.</h2>
Â  Â  Â  Â  <div class="mode-buttons">
Â  Â  Â  Â  Â  Â  <div class="mode-option">
Â  Â  Â  Â  Â  Â  Â  Â  <button id="classic-mode-btn">ğŸ“ í´ë˜ì‹ <span>ëª¨ë“œ</span></button>
Â  Â  Â  Â  Â  Â  Â  Â  <small class="mode-description">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ë¬´ì‘ìœ„ë¡œ ìƒì„±ë˜ëŠ” ë¬¸ì œë¥¼<br>ì›í•˜ëŠ” ë§Œí¼ ì—°ìŠµí•˜ì„¸ìš”!
Â  Â  Â  Â  Â  Â  Â  Â  </small>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  <div class="mode-option">
Â  Â  Â  Â  Â  Â  Â  Â  <button id="time-attack-mode-btn">â±ï¸ íƒ€ì„ì–´íƒ <span>ëª¨ë“œ</span></button>
Â  Â  Â  Â  Â  Â  Â  Â  <small class="mode-description">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ì •í•´ì§„ ì‹œê°„ ë™ì•ˆ<br>ë¹ ë¥´ê³  ì •í™•í•˜ê²Œ!
Â  Â  Â  Â  Â  Â  Â  Â  </small>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>
Â  Â  </div>
Â  Â Â 
Â  Â  <div id="setup-page">
Â  Â  Â  Â  <button id="back-to-mode-select-btn" class="home-button" style="position: absolute; top: 20px; left: 20px;">ëª¨ë“œ ì„ íƒìœ¼ë¡œ</button>
Â  Â  Â  Â  <h1>
Â  Â  Â  Â  Â  Â  <span class="desktop-title">ì„ ëŒ€ì¹­/ì ëŒ€ì¹­ë„í˜• ì™„ì „ ì •ë³µ</span>
Â  Â  Â  Â  Â  Â  <span class="mobile-title">ì„ ëŒ€ì¹­/ì ëŒ€ì¹­ë„í˜•<br>ì™„ì „ ì •ë³µ</span>
Â  Â  Â  Â  </h1>
Â  Â  Â  Â  <h2 style="text-align: center;">ë¬¸ì œ ìœ í˜• ë° ì„¤ì •</h2>

Â  Â  Â  Â  <div class="main-layout">
Â  Â  Â  Â  Â  Â  <div class="left-panel">
Â  Â  Â  Â  Â  Â  Â  Â  <div class="setting-group">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <h3>ë¬¸ì œ ìœ í˜• ì„ íƒ</h3>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div id="type-select" class="option-buttons">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button data-type="line" class="selected">ì„ ëŒ€ì¹­ë„í˜•</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button data-type="point">ì ëŒ€ì¹­ë„í˜•</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button data-type="both">ë‘˜ ë‹¤ í• ë˜ìš”</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  <div class="setting-group">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <h3>ë‚œì´ë„ ì„ íƒ</h3>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div id="difficulty-select" class="option-buttons">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button data-difficulty="practice">ì—°ìŠµ</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button data-difficulty="1" class="selected">â˜…</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button data-difficulty="2">â˜…â˜…</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  <div class="right-panel">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div class="settings-wrapper">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div id="classic-settings">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div class="setting-group">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <h3>ë¬¸ì œ ê°œìˆ˜ ì„¤ì •</h3>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <small style="margin-bottom: 10px;">(ìµœì†Œ 5, ìµœëŒ€ 50ë¬¸ì œ)</small>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div id="quantity-control">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button id="quantity-minus">-</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span id="problem-quantity" class="quantity-display">5</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button id="quantity-plus">+</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div id="time-attack-settings" style="display: none;">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div class="setting-group">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <h3>ë„ì „ ì‹œê°„ ì„¤ì •</h3>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div id="time-control" style="margin-top: 10px;">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button id="time-minus">&lt;</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span id="time-limit-display" class="quantity-display">3ë¶„</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button id="time-plus">&gt;</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div id="settings-overlay" style="display: none;">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <p id="overlay-message"></p>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div class="setting-group start-btn-container">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button id="start-quiz-btn" class="primary-btn">ì‹œì‘!</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  </div>
Â  Â Â 
Â  Â  <div id="problem-page">
Â  Â  Â  Â  <div class="problem-header">
Â  Â  Â  Â  Â  Â  <button class="home-button">
Â  Â  Â  Â  Â  Â  Â  Â  <span class="desktop-home">ğŸ  ì²« í˜ì´ì§€ë¡œ</span>
Â  Â  Â  Â  Â  Â  Â  Â  <span class="mobile-home">ğŸ </span>
Â  Â  Â  Â  Â  Â  </button>
Â  Â  Â  Â  Â  Â  <h2 id="problem-number">1ë²ˆì§¸ ë¬¸ì œ</h2>
Â  Â  Â  Â  Â  Â  <div id="timer-display"></div>
Â  Â  Â  Â  Â  Â  <div id="problem-counter-display"></div>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <p id="problem-instruction">ì•„ë˜ ë„í˜•ì€ ì„ ëŒ€ì¹­ë„í˜•ì…ë‹ˆë‹¤. ë‚˜ë¨¸ì§€ ë¶€ë¶„ì„ ì™„ì„±í•´ ì£¼ì„¸ìš”.</p>
Â  Â  Â  Â Â 
Â  Â  Â  Â  <div class="canvas-wrapper">
Â  Â  Â  Â  Â  Â  <canvas id="grid-canvas" width="400" height="400"></canvas>
Â  Â  Â  Â  </div>

Â  Â  Â  Â  <div class="canvas-controls">
Â  Â  Â  Â  Â  Â  <button id="mode-vertex" class="secondary-btn mode-btn-active" onclick="setCanvasMode('vertex')">1ë‹¨ê³„: ê¼­ì§“ì </button>
Â  Â  Â  Â  Â  Â  <button id="mode-line" class="secondary-btn" onclick="setCanvasMode('line')" disabled>2ë‹¨ê³„: ì„ ë¶„</button>
Â  Â  Â  Â  Â  Â  <button id="clear-canvas-btn" class="secondary-btn">ëª¨ë‘ ì§€ìš°ê¸°</button>
Â  Â  Â  Â  </div>
Â  Â  Â  Â Â 
Â  Â  Â  Â  <div class="problem-footer">
Â  Â  Â  Â  Â  Â  <div id="check-answer-container">
Â  Â  Â  Â  Â  Â  Â  Â  <button id="check-answer-btn" class="primary-btn">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span class="progress-bar"></span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span class="button-text">ì •ë‹µ í™•ì¸í•˜ê¸°</span>
Â  Â  Â  Â  Â  Â  Â  Â  </button>
Â  Â  Â  Â  Â  Â  Â  Â  <button id="next-problem-btn" class="primary-btn" style="display: none;">ë‹¤ìŒ ë¬¸ì œ ë„ì „í•˜ê¸°</button>
Â  Â  Â  Â  Â  Â  Â  Â  <small class="check-answer-guide">ê¾¹ ëˆ„ë¥´ê³  ìˆìœ¼ë©´ ì±„ì ë©ë‹ˆë‹¤!</small>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>
Â  Â  </div>

Â  Â  <div id="final-result-page">
Â  Â  Â  Â  <h2 id="final-result-title">í•™ìŠµ ì™„ë£Œ</h2>
Â  Â  Â  Â  <div class="final-result-layout">
Â  Â  Â  Â  Â  Â  <div class="result-left">
Â  Â  Â  Â  Â  Â  Â  Â  <p>ë‚˜ì˜ ì •í™•ë„</p>
Â  Â  Â  Â  Â  Â  Â  Â  <div id="final-accuracy">0%</div>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  <div class="result-right">
Â  Â  Â  Â  Â  Â  Â  Â  <p>í•œ ë²ˆì— ë§ì¶˜ ë¬¸ì œ: <span id="correct-count">0</span>ê°œ</p>
Â  Â  Â  Â  Â  Â  Â  Â  <p>ë‹¤ì‹œ ë„ì „í•´ ë§ì¶˜ ë¬¸ì œ: <span id="retried-count">0</span>ê°œ</p>
Â  Â  Â  Â  Â  Â  Â  Â  <p id="time-attack-avg-time" style="display: none;">ë¬¸ì œë‹¹ í‰ê·  ì†ë„: <span id="avg-time-display">0</span>ì´ˆ</p>
Â  Â  Â  Â  Â  Â  Â  Â  <p class="score-display">ìµœì¢… ì ìˆ˜: <span id="final-score">0</span>ì </p>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div class="result-buttons">
Â  Â  Â  Â  Â  Â  <button id="restart-btn" class="primary-btn">ìƒˆë¡œìš´ í•™ìŠµ ì‹œì‘í•˜ê¸°</button>
Â  Â  Â  Â  Â  Â  <button id="show-hof-btn" class="secondary-btn">ëª…ì˜ˆì˜ ì „ë‹¹ ë“±ë¡í•˜ê¸°</button>
Â  Â  Â  Â  </div>
Â  Â  </div>
</div>
<div class="footer">
Â  Â  Copyright Â© 2025 íœ´ë¥´ìŒ¤. All rights reserved.
</div>

<div id="result-popup-overlay" class="popup-overlay" style="display: none;">
Â  Â  <div class="result-popup popup-box">
Â  Â  Â  Â  <button class="close-btn" onclick="closePopup()">&times;</button>
Â  Â  Â  Â  <div class="popup-content">
Â  Â  Â  Â  Â  Â  <p id="popup-main-message"></p>
Â  Â  Â  Â  Â  Â  <p id="popup-detail-message"></p>
Â  Â  Â  Â  Â  Â  <button id="popup-next-btn" class="primary-btn" onclick="nextProblem()">ë‹¤ìŒ ë¬¸ì œ ë„ì „í•˜ê¸°</button>
Â  Â  Â  Â  </div>
Â  Â  </div>
</div>

<div id="qr-popup-overlay" class="popup-overlay" style="display: none;">
Â  Â  <div class="popup-qr popup-box">
Â  Â  Â  Â  <button class="close-btn" onclick="closeQrPopup()">&times;</button>
Â  Â  Â  Â  <img src="https://i.imgur.com/g4yS8yx.png" alt="QR Code">
Â  Â  </div>
</div>

<div id="hof-popup-overlay" class="popup-overlay" style="display: none;">
Â  Â  <div class="popup-hof popup-box">
Â  Â  Â  Â  <button class="close-btn" onclick="closeHofPopup()">&times;</button>
Â  Â  Â  Â  <h3>ğŸ† ëª…ì˜ˆì˜ ì „ë‹¹ğŸ†</h3>
Â  Â  Â  Â  <div class="hof-input-group">
Â  Â  Â  Â  Â  Â  <input type="text" id="hof-initial" placeholder="AAA" maxlength="3" oninput="this.value = this.value.toUpperCase().replace(/[^A-Z]/g, '')">
Â  Â  Â  Â  Â  Â  <button id="hof-submit-btn" class="primary-btn">ë“±ë¡</button>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div id="hof-message"></div>
Â  Â  Â  Â  <div class="hof-columns">
Â  Â  Â  Â  Â  Â  <div class="hof-column">
Â  Â  Â  Â  Â  Â  Â  Â  <h3>ğŸ“ í´ë˜ì‹ ëª¨ë“œ</h3>
Â  Â  Â  Â  Â  Â  Â  Â  <div class="hof-table-container">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <table id="hof-table-classic">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <thead>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <tr>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <th>ìˆœìœ„</th>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <th>ì´ë‹ˆì…œ</th>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <th>ì ìˆ˜</th>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </tr>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </thead>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <tbody>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </tbody>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </table>
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  <div class="hof-column">
Â  Â  Â  Â  Â  Â  Â  Â  <h3>â±ï¸ íƒ€ì„ì–´íƒ ëª¨ë“œ</h3>
Â  Â  Â  Â  Â  Â  Â  Â  <div class="hof-table-container">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <table id="hof-table-timeattack">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <thead>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <tr>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <th>ìˆœìœ„</th>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <th>ì´ë‹ˆì…œ</th>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <th>ì ìˆ˜</th>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </tr>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </thead>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <tbody>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </tbody>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </table>
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>
Â  Â  </div>
</div>

<div id="confirm-clear-popup-overlay" class="popup-overlay" style="display: none; background-color: rgba(255, 255, 255, 0.8);">
Â  Â  <div class="popup-box confirm-clear-popup">
Â  Â  Â  Â  <p>í‘œì‹œí•œ ì ê³¼ ì„ ë¶„ì„ ëª¨ë‘ ì§€ì›ë‹ˆë‹¤. <br> ê³„ì†í• ê¹Œìš”?</p>
Â  Â  Â  Â  <div class="confirm-buttons">
Â  Â  Â  Â  Â  Â  <button id="confirm-clear-yes-btn">ë„¤</button>
Â  Â  Â  Â  Â  Â  <button id="confirm-clear-no-btn" class="secondary-btn">ì•„ë‹ˆìš”</button>
Â  Â  Â  Â  </div>
Â  Â  </div>
</div>

<script>
Â  Â  const webAppUrl = 'https://soft-wood-cf8e.bbglara.workers.dev/';
Â  Â Â 
Â  Â  const timeOptions = [3, 5, 7];
Â  Â  let selectedType = 'line', totalProblems = 5, currentProblem = 0, canvasMode = 'vertex', score = { results: [] }, currentProblemAttempts = 0, selectedDifficulty = '1', finalAccuracyValue = 0, finalScoreValue = 0, hasSubmittedScore = false, isExitingIntentionally = false, gameMode = 'classic', timeLimitInMinutes = 3, remainingTime = 0, timerInterval = null;
Â  Â  const canvas = document.getElementById('grid-canvas'), ctx = canvas.getContext('2d'), canvasWrapper = document.querySelector('.canvas-wrapper');
Â  Â  let GRID_SIZE, GRID_COUNT, HALF_COUNT, CENTER_POINT, MIN_COORD, MAX_COORD;
Â  Â  const COLLINEARITY_THRESHOLD = 1.0, MIN_ANGLE_COSINE = Math.cos(30 * Math.PI / 180), MAX_ANGLE_COSINE = Math.cos(150 * Math.PI / 180), MIN_SLOPE_DIFF = 2.0, MIN_DIST = 2;
Â  Â  let problemVertices = [], problemLines = [], userVertices = [], userLines = [], tempLineStart = null, hoveredLine = null, problemList = [];

Â  Â  function setupGrid() {
Â  Â  Â  Â  GRID_COUNT = 16;
Â  Â  Â  Â  MIN_COORD = 2;
Â  Â  Â  Â  MAX_COORD = 14;
Â  Â  Â  Â  GRID_SIZE = canvas.width / GRID_COUNT;
Â  Â  Â  Â  HALF_COUNT = GRID_COUNT / 2;
Â  Â  Â  Â  CENTER_POINT = { x: HALF_COUNT, y: HALF_COUNT };
Â  Â  }

Â  Â  const allPages = ['mode-selection-page', 'setup-page', 'problem-page', 'final-result-page'];
Â  Â  function showPage(pageIdToShow) {
Â  Â  Â  Â  allPages.forEach(pageId => {
Â  Â  Â  Â  Â  Â  const page = document.getElementById(pageId);
Â  Â  Â  Â  Â  Â  if (page) {
Â  Â  Â  Â  Â  Â  Â  Â  const displayStyle = (pageId === 'mode-selection-page' || pageId === 'setup-page') ? 'flex' : 'block';
Â  Â  Â  Â  Â  Â  Â  Â  page.style.display = (pageId === pageIdToShow) ? displayStyle : 'none';
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  Â  Â  const qrBtn = document.getElementById('qr-code-btn');
Â  Â  Â  Â  if (qrBtn) {
Â  Â  Â  Â  Â  Â  qrBtn.style.display = (pageIdToShow === 'mode-selection-page' || pageIdToShow === 'setup-page') ? 'block' : 'none';
Â  Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  function resetGame() {
Â  Â  Â  Â  stopTimer();
Â  Â  Â  Â  clearGameState();
Â  Â  Â  Â  isExitingIntentionally = false;
Â  Â  Â  Â Â 
Â  Â  Â  Â  selectedType = 'line';Â 
Â  Â  Â  Â  totalProblems = 5;Â 
Â  Â  Â  Â  currentProblem = 0;Â 
Â  Â  Â  Â  canvasMode = 'vertex';Â 
Â  Â  Â  Â  score = { results: [] };Â 
Â  Â  Â  Â  currentProblemAttempts = 0;Â 
Â  Â  Â  Â  selectedDifficulty = '1';Â 
Â  Â  Â  Â  hasSubmittedScore = false;Â 
Â  Â  Â  Â  gameMode = 'classic';Â 
Â  Â  Â  Â  timeLimitInMinutes = 3;Â 
Â  Â  Â  Â  remainingTime = 0;Â 
Â  Â  Â  Â  problemList = [];Â 
Â  Â  Â  Â  userVertices = [];Â 
Â  Â  Â  Â  userLines = [];
Â  Â  Â  Â Â 
Â  Â  Â  Â  document.getElementById('problem-quantity').textContent = '5';
Â  Â  Â  Â  document.getElementById('time-limit-display').textContent = '3ë¶„';
Â  Â  Â  Â  document.getElementById('timer-display').style.display = 'none';
Â  Â  Â  Â  document.getElementById('problem-counter-display').style.display = 'none';

Â  Â  Â  Â  document.querySelectorAll('#type-select button').forEach(b => b.classList.remove('selected'));
Â  Â  Â  Â  document.querySelector('#type-select button[data-type="line"]').classList.add('selected');

Â  Â  Â  Â  document.querySelectorAll('#difficulty-select button').forEach(b => b.classList.remove('selected'));
Â  Â  Â  Â  document.querySelector('#difficulty-select button[data-difficulty="1"]').classList.add('selected');
Â  Â  Â  Â Â 
Â  Â  Â  Â  setupGrid();
Â  Â  Â  Â Â 
Â  Â  Â  Â  document.getElementById('classic-settings').style.display = 'block';
Â  Â  Â  Â  document.getElementById('time-attack-settings').style.display = 'none';
Â  Â  Â  Â  updateSettingsOverlay();
Â  Â  }

Â  Â  function isSamePoint(p1, p2) { if (!p1 || !p2) return false; return p1.x === p2.x && p1.y === p2.y; }
Â  Â  function isSameLine(l1, l2) { if (!l1 || !l2) return false; const p11 = l1.p1, p12 = l1.p2, p21 = l2.p1, p22 = l2.p2; return (isSamePoint(p11, p21) && isSamePoint(p12, p22)) || (isSamePoint(p11, p22) && isSamePoint(p12, p21)); }
Â  Â  function isLineExists(newLine) { return userLines.some(existingLine => isSameLine(existingLine, newLine)); }

Â  Â  function getRandomInt(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min + 1)) + min; }
Â  Â  function isTooClose(newV, vertices, minDist = MIN_DIST) { const minDistSq = minDist ** 2; for (const v of vertices) { const distSq = (newV.x - v.x) ** 2 + (newV.y - v.y) ** 2; if (distSq < minDistSq) return true; } return false; }
Â  Â  function isTooLinear(p1, p2, p3) { const crossProduct = (p2.y - p1.y) * (p3.x - p2.x) - (p3.y - p2.y) * (p2.x - p1.x); return Math.abs(crossProduct) < COLLINEARITY_THRESHOLD; }
Â  Â  function isTooSharpAngle(p1, p2, p3) { const v1x = p1.x - p2.x, v1y = p1.y - p2.y, v2x = p3.x - p2.x, v2y = p3.y - p2.y, dotProduct = v1x * v2x + v1y * v2y, mag1 = Math.sqrt(v1x * v1x + v1y * v1y), mag2 = Math.sqrt(v2x * v2x + v2y * v2y); if (mag1 === 0 || mag2 === 0) return true; const cosine = dotProduct / (mag1 * mag2); return cosine > MIN_ANGLE_COSINE || cosine < MAX_ANGLE_COSINE; }
Â  Â  function isTooWeakSlope(p1, p2) { const dx = Math.abs(p2.x - p1.x), dy = Math.abs(p2.y - p1.y); return (dx <= MIN_SLOPE_DIFF || dy <= MIN_SLOPE_DIFF) || (dx > 0 && dy > 0 && Math.abs(dy / dx) < 1); }
Â  Â  function isProblemTooLinear(vertices, newV) { if (vertices.length < 2) return false; const p1 = vertices[vertices.length - 2], p2 = vertices[vertices.length - 1]; for (let i = 0; i < vertices.length - 1; i++) if (isTooLinear(vertices[i], p2, newV)) return true; return isTooLinear(p1, p2, newV); }
Â  Â  function isProblemTooSharp(vertices, newV) { if (vertices.length < 2) return false; const p1 = vertices[vertices.length - 2], p2 = vertices[vertices.length - 1]; const isAxisPoint = (p) => p.x === HALF_COUNT || p.y === HALF_COUNT || (p.x === p.y); if (isAxisPoint(p1) && isAxisPoint(p2) && isAxisPoint(newV)) return false; for(let i=1; i<vertices.length; i++) if(isTooSharpAngle(vertices[i-1], vertices[i], newV)) return true; return isTooSharpAngle(p1, p2, newV); }
Â  Â  function distSq(p1, p2) { return (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2; }
Â  Â  function calculateSymmetricPoint(v, type, isSlantedAxis = false, axisDirection = 'vertical') { let symX, symY; const C = HALF_COUNT; if (type === 'line') { if (isSlantedAxis) { symX = v.y; symY = v.x; } else if (axisDirection === 'horizontal') { symX = v.x; symY = 2 * C - v.y; } else { symX = 2 * C - v.x; symY = v.y; } } else if (type === 'point') { symX = 2 * C - v.x; symY = 2 * C - v.y; } else return v; return { x: Math.round(symX), y: Math.round(symY) }; }
Â  Â  function createSequentialLines(vertices, close = false) { const lines = []; if (vertices.length < 2) return lines; const count = vertices.length; for (let i = 0; i < count; i++) { const p1 = vertices[i], p2 = vertices[(i + 1) % count]; if (!close && i === count - 1) break; lines.push({ p1, p2 }); } return lines; }
Â  Â  function findPointSymmetricBoundary(points) { if (points.length < 3) return points; const C = CENTER_POINT, centerPoint = points.find(p => isSamePoint(p, C)), nonCenterPoints = points.filter(p => !isSamePoint(p, C)); nonCenterPoints.sort((a, b) => Math.atan2(a.y - C.y, a.x - C.x) - Math.atan2(b.y - C.y, b.x - C.x)); let sortedPoints = []; if (centerPoint) sortedPoints.push(centerPoint); sortedPoints = sortedPoints.concat(nonCenterPoints); return sortedPoints.filter((v, i, self) => i === self.findIndex((t) => isSamePoint(t, v))); }
Â  Â  function sortSlantedAxisVertices(vertices) { const axisPoints = vertices.filter(v => v.x === v.y).sort((a, b) => a.y - b.y), nonAxisPoints = vertices.filter(v => v.x !== v.y), p1 = axisPoints[0], p2 = axisPoints[1], belowAxis = nonAxisPoints.filter(p => p.y < p.x), aboveAxis = nonAxisPoints.filter(p => p.y > p.x); belowAxis.sort((a,b) => Math.atan2(a.y - p1.y, a.x - p1.x) - Math.atan2(b.y - p1.y, b.x - p1.x)); aboveAxis.sort((a,b) => Math.atan2(b.y - p2.y, b.x - p2.x) - Math.atan2(a.y - p2.y, a.x - p2.x)); return [p1, ...belowAxis, p2, ...aboveAxis]; }
Â  Â Â 
Â  Â  function generateRandomProblem(type, forceVertices = null) {
Â  Â  Â  Â  const MAX_ATTEMPTS_PER_POINT = 100;

Â  Â  Â  Â  if (type === 'line') {
Â  Â  Â  Â  Â  Â  let nVertices, minCoord, maxCoord;
Â  Â  Â  Â  Â  Â  let isSlantedAxis = false;
Â  Â  Â  Â  Â  Â  let axisDirection = 'vertical';
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const difficulty = (selectedDifficulty === 'practice') ? '1' : selectedDifficulty;

Â  Â  Â  Â  Â  Â  if (forceVertices) {
Â  Â  Â  Â  Â  Â  Â  Â  Â nVertices = forceVertices;
Â  Â  Â  Â  Â  Â  Â  Â  Â minCoord = MIN_COORD;
Â  Â  Â  Â  Â  Â  Â  Â  Â maxCoord = MAX_COORD;
Â  Â  Â  Â  Â  Â  Â  Â  Â isSlantedAxis = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â axisDirection = Math.random() < 0.5 ? 'vertical' : 'horizontal';
Â  Â  Â  Â  Â  Â  } else if (difficulty == 2) {
Â  Â  Â  Â  Â  Â  Â  Â  isSlantedAxis = Math.random() < 0.5;
Â  Â  Â  Â  Â  Â  Â  Â  if (isSlantedAxis) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  nVertices = getRandomInt(3, 4);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  minCoord = MIN_COORD;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  maxCoord = MAX_COORD;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  axisDirection = 'slanted';
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  nVertices = getRandomInt(5, 6);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  minCoord = MIN_COORD - 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  maxCoord = MAX_COORD + 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  axisDirection = Math.random() < 0.5 ? 'vertical' : 'horizontal';
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  isSlantedAxis = false;
Â  Â  Â  Â  Â  Â  Â  Â  nVertices = 4;
Â  Â  Â  Â  Â  Â  Â  Â  minCoord = MIN_COORD;
Â  Â  Â  Â  Â  Â  Â  Â  maxCoord = MAX_COORD;
Â  Â  Â  Â  Â  Â  Â  Â  axisDirection = Math.random() < 0.5 ? 'vertical' : 'horizontal';
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  if (isSlantedAxis) {
Â  Â  Â  Â  Â  Â  Â  Â  const axisMidPoint = { x: HALF_COUNT, y: HALF_COUNT };
Â  Â  Â  Â  Â  Â  Â  Â  const axisLength = getRandomInt(Math.floor(GRID_COUNT * 0.15), Math.floor(GRID_COUNT * 0.35));
Â  Â  Â  Â  Â  Â  Â  Â  const p1 = {x: axisMidPoint.x - axisLength, y: axisMidPoint.y - axisLength};
Â  Â  Â  Â  Â  Â  Â  Â  const p2 = {x: axisMidPoint.x + axisLength, y: axisMidPoint.y + axisLength};
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  let tempVertices = [p1];

Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < nVertices - 2; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let newV, success = false, attemptCount = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  while (!success && attemptCount < MAX_ATTEMPTS_PER_POINT) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let x = getRandomInt(minCoord, maxCoord);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let y = getRandomInt(minCoord, x - 1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newV = { x: x, y: y };

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let isValid = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (tempVertices.length >= 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(isTooSharpAngle(tempVertices[tempVertices.length-2], tempVertices[tempVertices.length-1], newV)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isValid = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (tempVertices.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let symV = calculateSymmetricPoint(newV, 'line', true);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (isTooSharpAngle(tempVertices[tempVertices.length - 1], newV, symV)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isValid = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (isValid && !isTooClose(newV, tempVertices) && !isProblemTooLinear(tempVertices, newV)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tempVertices.push(newV);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  success = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  attemptCount++;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!success) return null;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  tempVertices.push(p2);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  let allVertices = [...tempVertices];
Â  Â  Â  Â  Â  Â  Â  Â  if (allVertices.length < 3) return null;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (isTooLinear(allVertices[allVertices.length-2], allVertices[allVertices.length-1], allVertices[0]) || isTooSharpAngle(allVertices[allVertices.length-2], allVertices[allVertices.length-1], allVertices[0])) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  let allVerticesSorted = sortSlantedAxisVertices(allVertices);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (allVerticesSorted.length >= 3) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < allVerticesSorted.length - 2; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (isTooLinear(allVerticesSorted[i], allVerticesSorted[i+1], allVerticesSorted[i+2])) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  const allLines = createSequentialLines(allVerticesSorted, false);
Â  Â  Â  Â  Â  Â  Â  Â  const initialLines = allLines.filter(line => ((line.p1.x + line.p2.x)/2) > ((line.p1.y + line.p2.y)/2));
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  let initialVertices = initialLines.reduce((acc, line) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!acc.some(v => isSamePoint(v, line.p1))) acc.push(line.p1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!acc.some(v => isSamePoint(v, line.p2))) acc.push(line.p2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return acc;
Â  Â  Â  Â  Â  Â  Â  Â  }, []);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if(initialVertices.filter(v => v.x === v.y).length < 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type: 'line', isSlantedAxis: true, axisDirection: 'slanted',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  initialVertices, initialLines, allVertices: allVerticesSorted, allLines
Â  Â  Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â  } else { // Not slanted
Â  Â  Â  Â  Â  Â  Â  Â  let initialVertices;
Â  Â  Â  Â  Â  Â  Â  Â  if (axisDirection === 'vertical') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const axisPoint1 = { x: HALF_COUNT, y: getRandomInt(minCoord, HALF_COUNT - 2) };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const axisPoint2 = { x: HALF_COUNT, y: getRandomInt(HALF_COUNT + 2, maxCoord) };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let nonAxisPoints = [];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < nVertices - 2; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let newV, success = false, attemptCount = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  while (!success && attemptCount < MAX_ATTEMPTS_PER_POINT) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newV = { x: getRandomInt(minCoord, HALF_COUNT - 1), y: getRandomInt(axisPoint1.y, axisPoint2.y) };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let isValid = !isTooClose(newV, [...nonAxisPoints, axisPoint1, axisPoint2]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (nonAxisPoints.length > 0 && isTooWeakSlope(nonAxisPoints[nonAxisPoints.length - 1], newV)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isValid = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (isValid) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  nonAxisPoints.push(newV);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  success = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  attemptCount++;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!success) return null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  nonAxisPoints.sort((a, b) => a.x - b.x);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  initialVertices = [axisPoint1, ...nonAxisPoints, axisPoint2];
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (initialVertices.length < 2) return null;
Â  Â  Â  Â  Â  Â  Â  Â  if (initialVertices.length >= 3) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < initialVertices.length - 2; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (isTooLinear(initialVertices[i], initialVertices[i+1], initialVertices[i+2])) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  let allVertices = initialVertices.concat(initialVertices.map(v => calculateSymmetricPoint(v, 'line', false, axisDirection)).reverse());
Â  Â  Â  Â  Â  Â  Â  Â  allVertices = allVertices.filter((v, i, self) => i === self.findIndex((t) => isSamePoint(t, v)));
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type: 'line', isSlantedAxis: false, axisDirection,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  initialVertices, initialLines: createSequentialLines(initialVertices, false),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  allVertices, allLines: createSequentialLines(allVertices, true)
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } else if (type === 'point') {
Â  Â  Â  Â  Â  Â  const difficulty = (selectedDifficulty === 'practice') ? '1' : selectedDifficulty;
Â  Â  Â  Â  Â  Â  const numPoints = forceVertices ? forceVertices : (difficulty == 1) ? 4 : getRandomInt(5, 6);
Â  Â  Â  Â  Â  Â  let initialPoints = [];
Â  Â  Â  Â  Â  Â  const isHorizontalAxis = Math.random() < 0.5;
Â  Â  Â  Â  Â  Â  let lineStart, lineEnd;

Â  Â  Â  Â  Â  Â  if(isHorizontalAxis) {
Â  Â  Â  Â  Â  Â  Â  Â  const y = CENTER_POINT.y;
Â  Â  Â  Â  Â  Â  Â  Â  const halfLength = getRandomInt(Math.floor(GRID_COUNT * 0.15), Math.floor(GRID_COUNT * 0.35));
Â  Â  Â  Â  Â  Â  Â  Â  lineStart = {x: CENTER_POINT.x - halfLength, y: y};
Â  Â  Â  Â  Â  Â  Â  Â  lineEnd = {x: CENTER_POINT.x + halfLength, y: y};
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  const x = CENTER_POINT.x;
Â  Â  Â  Â  Â  Â  Â  Â  const halfLength = getRandomInt(Math.floor(GRID_COUNT * 0.15), Math.floor(GRID_COUNT * 0.35));
Â  Â  Â  Â  Â  Â  Â  Â  lineStart = {x: x, y: CENTER_POINT.y - halfLength};
Â  Â  Â  Â  Â  Â  Â  Â  lineEnd = {x: x, y: CENTER_POINT.y + halfLength};
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  initialPoints.push(lineStart);
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  let halfVertices = [];
Â  Â  Â  Â  Â  Â  for(let i = 0; i < numPoints - 2; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  let newV, success = false, attemptCount = 0;
Â  Â  Â  Â  Â  Â  Â  Â  while(!success && attemptCount < MAX_ATTEMPTS_PER_POINT) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let x, y;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(isHorizontalAxis) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  x = getRandomInt(MIN_COORD, MAX_COORD);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  y = getRandomInt(MIN_COORD, CENTER_POINT.y - 1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  x = getRandomInt(MIN_COORD, CENTER_POINT.x - 1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  y = getRandomInt(MIN_COORD, MAX_COORD);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newV = {x: x, y: y};
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(!isTooClose(newV, [...initialPoints, ...halfVertices])) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  halfVertices.push(newV);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  success = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  attemptCount++;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if(!success) return null;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  halfVertices.sort((a, b) => Math.atan2(a.y - CENTER_POINT.y, a.x - CENTER_POINT.x) - Math.atan2(b.y - CENTER_POINT.y, b.x - CENTER_POINT.x));
Â  Â  Â  Â  Â  Â  initialPoints = initialPoints.concat(halfVertices);
Â  Â  Â  Â  Â  Â  initialPoints.push(lineEnd);

Â  Â  Â  Â  Â  Â  let allVertices = [];
Â  Â  Â  Â  Â  Â  let processed = new Set();
Â  Â  Â  Â  Â  Â  initialPoints.forEach(p => {
Â  Â  Â  Â  Â  Â  Â  Â  const key = `${p.x},${p.y}`;
Â  Â  Â  Â  Â  Â  Â  Â  if (!processed.has(key)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  allVertices.push(p);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  processed.add(key);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const symV = calculateSymmetricPoint(p, 'point');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const symKey = `${symV.x},${symV.y}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!processed.has(symKey)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  allVertices.push(symV);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  processed.add(symKey);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  allVertices = findPointSymmetricBoundary(allVertices);

Â  Â  Â  Â  Â  Â  if (allVertices.length >= 3) {
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < allVertices.length; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const len = allVertices.length;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const p1 = allVertices[(i - 1 + len) % len];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const p2 = allVertices[i];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const p3 = allVertices[(i + 1) % len];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (isTooLinear(p1, p2, p3) || isTooSharpAngle(p1, p2, p3)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const allLines = createSequentialLines(allVertices, true);
Â  Â  Â  Â  Â  Â  const initialLines = [];
Â  Â  Â  Â  Â  Â  const initialSet = new Set(initialPoints.map(p => `${p.x},${p.y}`));
Â  Â  Â  Â  Â  Â  allLines.forEach(line => {
Â  Â  Â  Â  Â  Â  Â  Â  if(initialSet.has(`${line.p1.x},${line.p1.y}`) && initialSet.has(`${line.p2.x},${line.p2.y}`)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  initialLines.push(line);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  Â  Â  Â  type: 'point', initialVertices: initialPoints, initialLines, allVertices, allLines
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  }
Â  Â  Â  Â  return null;
Â  Â  }
Â  Â Â 
Â  Â  function initializeSetupListeners() {
Â  Â  Â  Â  document.querySelectorAll('#type-select button').forEach(button => {
Â  Â  Â  Â  Â  Â  button.addEventListener('click', handleTypeSelect);
Â  Â  Â  Â  });
Â  Â  Â  Â  document.querySelectorAll('#difficulty-select button').forEach(button => {
Â  Â  Â  Â  Â  Â  button.addEventListener('click', handleDifficultySelect);
Â  Â  Â  Â  });
Â  Â  Â  Â  document.getElementById('quantity-minus').addEventListener('click', () => changeQuantity(-5));
Â  Â  Â  Â  document.getElementById('quantity-plus').addEventListener('click', () => changeQuantity(5));
Â  Â  Â  Â  document.getElementById('time-minus').addEventListener('click', () => changeTimeLimit(-1));
Â  Â  Â  Â  document.getElementById('time-plus').addEventListener('click', () => changeTimeLimit(1));
Â  Â  }

function updateSettingsOverlay() {
Â  Â  const overlay = document.getElementById('settings-overlay');
Â  Â  const message = document.getElementById('overlay-message');
Â  Â  const isPractice = selectedDifficulty === 'practice';

Â  Â  if (isPractice) {
Â  Â  Â  Â  overlay.style.display = 'flex';
Â  Â  Â  Â  if (gameMode === 'classic') {
Â  Â  Â  Â  Â  Â  message.innerHTML = 'ë¬¸ì œ ê°œìˆ˜ëŠ”<br>3ê°œë¡œ ê³ ì •ë©ë‹ˆë‹¤.';
Â  Â  Â  Â  } else { // timeAttack
Â  Â  Â  Â  Â  Â  message.innerHTML = 'ì‹œê°„ì€ 2ë¶„ìœ¼ë¡œ<br>ê³ ì •ë©ë‹ˆë‹¤.';
Â  Â  Â  Â  }
Â  Â  } else {
Â  Â  Â  Â  overlay.style.display = 'none';
Â  Â  }
}

Â  Â  function selectGameMode(mode) {
Â  Â  Â  Â  gameMode = mode;
Â  Â  Â  Â  const classicSettings = document.getElementById('classic-settings');
Â  Â  Â  Â  const timeAttackSettings = document.getElementById('time-attack-settings');

Â  Â  Â  Â  if (gameMode === 'classic') {
Â  Â  Â  Â  Â  Â  classicSettings.style.display = 'block';
Â  Â  Â  Â  Â  Â  timeAttackSettings.style.display = 'none';
Â  Â  Â  Â  } else { // timeAttack
Â  Â  Â  Â  Â  Â  classicSettings.style.display = 'none';
Â  Â  Â  Â  Â  Â  timeAttackSettings.style.display = 'block';
Â  Â  Â  Â  }
Â  Â  Â  Â  updateSettingsOverlay();
Â  Â  Â  Â  showPage('setup-page');
Â  Â  }

Â  Â  function changeTimeLimit(direction) {
Â  Â  Â  Â  const display = document.getElementById('time-limit-display');
Â  Â  Â  Â  const currentIndex = timeOptions.indexOf(timeLimitInMinutes);
Â  Â  Â  Â  let nextIndex = currentIndex + direction;

Â  Â  Â  Â  if (nextIndex < 0) {
Â  Â  Â  Â  Â  Â  nextIndex = timeOptions.length - 1;
Â  Â  Â  Â  } else if (nextIndex >= timeOptions.length) {
Â  Â  Â  Â  Â  Â  nextIndex = 0;
Â  Â  Â  Â  }

Â  Â  Â  Â  timeLimitInMinutes = timeOptions[nextIndex];
Â  Â  Â  Â  display.textContent = timeLimitInMinutes + 'ë¶„';
Â  Â  }

Â  Â  function nextProblem() {
Â  Â  Â  Â  closePopup();
Â  Â  Â  Â  currentProblem++;
Â  Â  Â  Â Â 
Â  Â  Â  Â  currentProblemAttempts = 0;
Â  Â  Â  Â  userVertices = [];
Â  Â  Â  Â  userLines = [];

Â  Â  Â  Â  if (gameMode === 'timeAttack') {
Â  Â  Â  Â  Â  Â  if (timerInterval) { // End of game is handled by timer
Â  Â  Â  Â  Â  Â  Â  Â  let newProblem = null;
Â  Â  Â  Â  Â  Â  Â  Â  let attempt = 0;
Â  Â  Â  Â  Â  Â  Â  Â  const MAX_ATTEMPTS_NEXT = 100;
Â  Â  Â  Â  Â  Â  Â  Â  while (!newProblem && attempt < MAX_ATTEMPTS_NEXT) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let type = (selectedType === 'both') ? (Math.random() < 0.5 ? 'line' : 'point') : selectedType;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newProblem = generateRandomProblem(type);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  attempt++;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (newProblem) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  problemList.push(newProblem);
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Could not generate new problem, end game
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  stopTimer();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  showFinalResult();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  // Timer already stopped, just show results
Â  Â  Â  Â  Â  Â  Â  Â  showFinalResult();
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (gameMode === 'classic' && currentProblem >= totalProblems) {
Â  Â  Â  Â  Â  Â  showFinalResult();
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }

Â  Â  Â  Â  loadProblem();
Â  Â  Â  Â  saveGameState();
Â  Â  }


Â  Â  function handleTypeSelect(event) {
Â  Â  Â  Â  document.querySelectorAll('#type-select button').forEach(b => b.classList.remove('selected'));
Â  Â  Â  Â  event.currentTarget.classList.add('selected');
Â  Â  Â  Â  selectedType = event.currentTarget.getAttribute('data-type');
Â  Â  }
Â  Â Â 
Â  Â  function handleDifficultySelect(event) {
Â  Â  Â  Â  document.querySelectorAll('#difficulty-select button').forEach(b => b.classList.remove('selected'));
Â  Â  Â  Â  event.currentTarget.classList.add('selected');
Â  Â  Â  Â  selectedDifficulty = event.currentTarget.getAttribute('data-difficulty');
Â  Â  Â  Â  updateSettingsOverlay();
Â  Â  }

Â  Â  function changeQuantity(delta) {
Â  Â  Â  Â  const current = parseInt(document.getElementById('problem-quantity').textContent);
Â  Â  Â  Â  let newQuantity = current + delta;
Â  Â  Â  Â  if (newQuantity < 5) newQuantity = 5;
Â  Â  Â  Â  if (newQuantity > 50) newQuantity = 50;
Â  Â  Â  Â  document.getElementById('problem-quantity').textContent = newQuantity;
Â  Â  Â  Â  totalProblems = newQuantity;
Â  Â  }

Â  Â  function generateProblemWithRetry(type, forceVertices = null) {
Â  Â  Â  Â  let newProblem = null;
Â  Â  Â  Â  let attempt = 0;
Â  Â  Â  Â  const MAX_ATTEMPTS = 100;
Â  Â  Â  Â  while (!newProblem && attempt < MAX_ATTEMPTS) {
Â  Â  Â  Â  Â  Â  newProblem = generateRandomProblem(type, forceVertices);
Â  Â  Â  Â  Â  Â  attempt++;
Â  Â  Â  Â  }
Â  Â  Â  Â  return newProblem;
Â  Â  }

function startQuiz() {
Â  Â  // 1. Clear all previous game state to prevent carryover issues.
Â  Â  currentProblem = 0;
Â  Â  score = { results: [] };
Â  Â  currentProblemAttempts = 0;
Â  Â  userVertices = [];
Â  Â  userLines = [];
Â  Â  tempLineStart = null;
Â  Â  hoveredLine = null;
Â  Â  problemList = [];
Â  Â  hasSubmittedScore = false;

Â  Â  // 2. Set quiz parameters based on mode and difficulty.
Â  Â  if (selectedDifficulty === 'practice') {
Â  Â  Â  Â  if (gameMode === 'timeAttack') {
Â  Â  Â  Â  Â  Â  timeLimitInMinutes = 2; // Fixed time limit for practice mode
Â  Â  Â  Â  }
Â  Â  Â  Â  totalProblems = 3; // Fixed number of problems for practice mode
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Generate a specific set of practice problems
Â  Â  Â  Â  if (selectedType === 'line') {
Â  Â  Â  Â  Â  Â  problemList.push(generateProblemWithRetry('line', 3));
Â  Â  Â  Â  Â  Â  problemList.push(generateProblemWithRetry('line', 4));
Â  Â  Â  Â  Â  Â  problemList.push(generateProblemWithRetry('line', 5));
Â  Â  Â  Â  } else if (selectedType === 'point') {
Â  Â  Â  Â  Â  Â  problemList.push(generateProblemWithRetry('point', 4));
Â  Â  Â  Â  Â  Â  problemList.push(generateProblemWithRetry('point', 4));
Â  Â  Â  Â  Â  Â  problemList.push(generateProblemWithRetry('point', 4));
Â  Â  Â  Â  } else { // both
Â  Â  Â  Â  Â  Â  problemList.push(generateProblemWithRetry('line', 3));
Â  Â  Â  Â  Â  Â  problemList.push(generateProblemWithRetry('line', 4));
Â  Â  Â  Â  Â  Â  problemList.push(generateRandomProblem('point', 4));
Â  Â  Â  Â  }
Â  Â  Â  Â  problemList = problemList.filter(p => p !== null);
Â  Â  Â  Â  totalProblems = problemList.length; // Finalize total problems based on successful generation

Â  Â  } else { // Normal Mode
Â  Â  Â  Â  let problemsToGenerate = (gameMode === 'classic') ? totalProblems : 1;
Â  Â  Â  Â  let attempt = 0;
Â  Â  Â  Â  const MAX_ATTEMPTS = problemsToGenerate * 20;
Â  Â  Â  Â  let generatedVertexStrings = new Set();
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Generate problems dynamically
Â  Â  Â  Â  while (problemList.length < problemsToGenerate && attempt < MAX_ATTEMPTS) {
Â  Â  Â  Â  Â  Â  let type = (selectedType === 'both') ? (Math.random() < 0.5 ? 'line' : 'point') : selectedType;
Â  Â  Â  Â  Â  Â  const newProblem = generateRandomProblem(type);
Â  Â  Â  Â  Â  Â  if (newProblem && newProblem.initialVertices.length >= 2) {
Â  Â  Â  Â  Â  Â  Â  Â  const vertexString = JSON.stringify(newProblem.initialVertices.map(v => `${v.x},${v.y}`).sort());
Â  Â  Â  Â  Â  Â  Â  Â  if (!generatedVertexStrings.has(vertexString)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  problemList.push(newProblem);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  generatedVertexStrings.add(vertexString);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  attempt++;
Â  Â  Â  Â  }
Â  Â  Â  Â  if (gameMode === 'classic') {
Â  Â  Â  Â  Â  Â  totalProblems = problemList.length; // Adjust totalProblems to the actual number generated
Â  Â  Â  Â  }
Â  Â  }

Â  Â  // 3. Handle problem generation failure.
Â  Â  if (problemList.length === 0) {
Â  Â  Â  Â  alert('ë¬¸ì œ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ì„¤ì •ìœ¼ë¡œ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.');
Â  Â  Â  Â  location.reload();
Â  Â  Â  Â  return;
Â  Â  }
Â  Â Â 
Â  Â  // 4. Start the quiz.
Â  Â  showPage('problem-page');
Â  Â  if (gameMode === 'timeAttack') startTimer();
Â  Â  loadProblem();
}
Â  Â Â 
Â  Â  function loadProblem() {
Â  Â  Â  Â  const isTimed = gameMode === 'timeAttack';
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (!isTimed && currentProblem >= totalProblems && totalProblems > 0) {
Â  Â  Â  Â  Â  Â  showFinalResult();
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (isTimed && currentProblem >= problemList.length && !timerInterval) {
Â  Â  Â  Â  Â  Â  showFinalResult();
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  const timerDisplay = document.getElementById('timer-display');
Â  Â  Â  Â  const counterDisplay = document.getElementById('problem-counter-display');

Â  Â  Â  Â  if (isTimed) {
Â  Â  Â  Â  Â  Â  counterDisplay.style.display = 'none';
Â  Â  Â  Â  Â  Â  timerDisplay.style.display = 'block';
Â  Â  Â  Â  } else { // Classic
Â  Â  Â  Â  Â  Â  counterDisplay.style.display = 'block';
Â  Â  Â  Â  Â  Â  timerDisplay.style.display = 'none';
Â  Â  Â  Â  Â  Â  counterDisplay.textContent = 'ë‚¨ì€ ë¬¸ì œ ' + (totalProblems - (currentProblem + 1)) + 'ê°œ';
Â  Â  Â  Â  }

Â  Â  Â  Â  const currentP = problemList[currentProblem];
Â  Â  Â  Â  if(!currentP) { // Failsafe for empty problem
Â  Â  Â  Â  Â  Â  console.error("Problem could not be loaded.", { currentProblem, problemList });
Â  Â  Â  Â  Â  Â  showFinalResult();
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }

Â  Â  Â  Â  const pType = currentP.type === 'line' ? 'ì„ ëŒ€ì¹­' : 'ì ëŒ€ì¹­';
Â  Â  Â  Â Â 
Â  Â  Â  Â  let problemNumText = `${currentProblem + 1}ë²ˆì§¸ ë¬¸ì œ (${pType})`;
Â  Â  Â  Â  const pTypeText = currentP.type === 'line' ? 'ì„ ëŒ€ì¹­ë„í˜•' : 'ì ëŒ€ì¹­ë„í˜•';
Â  Â  Â  Â  let instructionText = `ì•„ë˜ ë„í˜•ì€ ${pTypeText}ì…ë‹ˆë‹¤. ë‚˜ë¨¸ì§€ ë¶€ë¶„ì„ ì™„ì„±í•´ ì£¼ì„¸ìš”.`;

Â  Â  Â  Â  if (window.innerWidth < 480) {
Â  Â  Â  Â  Â  Â  problemNumText = `${currentProblem + 1}ë²ˆì§¸ ë¬¸ì œ<br>(${pType})`;
Â  Â  Â  Â  Â  Â  instructionText = `ì•„ë˜ ë„í˜•ì€ ${pTypeText}ì…ë‹ˆë‹¤.<br>ë‚˜ë¨¸ì§€ ë¶€ë¶„ì„ ì™„ì„±í•´ ì£¼ì„¸ìš”.`;
Â  Â  Â  Â  }
Â  Â  Â  Â  document.getElementById('problem-number').innerHTML = problemNumText;
Â  Â  Â  Â  document.getElementById('problem-instruction').innerHTML = instructionText;
Â  Â  Â  Â Â 
Â  Â  Â  Â  document.getElementById('check-answer-btn').style.display = 'block';
Â  Â  Â  Â  document.getElementById('next-problem-btn').style.display = 'none';
Â  Â  Â  Â Â 
Â  Â  Â  Â  closePopup();
Â  Â  Â  Â Â 
Â  Â  Â  Â  problemVertices = currentP.initialVertices;
Â  Â  Â  Â  problemLines = currentP.initialLines;
Â  Â  Â  Â  tempLineStart = null;
Â  Â  Â  Â  hoveredLine = null;
Â  Â  Â  Â Â 
Â  Â  Â  Â  setCanvasMode('vertex');
Â  Â  Â  Â Â 
Â  Â  Â  Â  redrawCanvas();
Â  Â  }
Â  Â Â 
Â  Â  function clearCanvas(clearUserDrawing) {
Â  Â  Â  Â  if (clearUserDrawing) {
Â  Â  Â  Â  Â  Â  userVertices = [];
Â  Â  Â  Â  Â  Â  userLines = [];
Â  Â  Â  Â  Â  Â  tempLineStart = null;
Â  Â  Â  Â  Â  Â  hoveredLine = null;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  redrawCanvas();
Â  Â  Â  Â  setCanvasMode('vertex');
Â  Â  Â  Â  closePopup();
Â  Â  Â  Â Â 
Â  Â  Â  Â  document.getElementById('check-answer-btn').style.display = 'block';
Â  Â  Â  Â  document.getElementById('next-problem-btn').style.display = 'none';
Â  Â  }
Â  Â Â 
Â  Â  function renderProblemVertices() {
Â  Â  Â  Â  document.querySelectorAll('.problem-dot').forEach(dot => dot.remove());
Â  Â  Â  Â  problemVertices.forEach((v) => {
Â  Â  Â  Â  Â  Â  const dot = document.createElement('div');
Â  Â  Â  Â  Â  Â  dot.className = 'problem-dot';
Â  Â  Â  Â  Â  Â  dot.style.left = `${(v.x / GRID_COUNT) * 100}%`;
Â  Â  Â  Â  Â  Â  dot.style.top = `${(v.y / GRID_COUNT) * 100}%`;
Â  Â  Â  Â  Â  Â  canvasWrapper.appendChild(dot);
Â  Â  Â  Â  });
Â  Â  }

Â  Â  function drawGrid() {
Â  Â  Â  Â  ctx.strokeStyle = '#333';
Â  Â  Â  Â  ctx.lineWidth = 0.5;
Â  Â  Â  Â Â 
Â  Â  Â  Â  ctx.setLineDash([1, 4]);
Â  Â  Â  Â Â 
Â  Â  Â  Â  for (let x = 0; x <= canvas.width; x += GRID_SIZE) {
Â  Â  Â  Â  Â  Â  ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
Â  Â  Â  Â  }
Â  Â  Â  Â  for (let y = 0; y <= canvas.height; y += GRID_SIZE) {
Â  Â  Â  Â  Â  Â  ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  ctx.setLineDash([]);

Â  Â  Â  Â  if (problemList.length > currentProblem && problemList[currentProblem]) {
Â  Â  Â  Â  Â  Â  const currentP = problemList[currentProblem];
Â  Â  Â  Â  Â  Â  ctx.strokeStyle = '#ff0000';
Â  Â  Â  Â  Â  Â  ctx.lineWidth = 2;
Â  Â  Â  Â  Â  Â  if (currentP.type === 'line') {
Â  Â  Â  Â  Â  Â  Â  Â  if (currentP.isSlantedAxis) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.moveTo(0, 0);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.lineTo(canvas.width, canvas.height);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.stroke();
Â  Â  Â  Â  Â  Â  Â  Â  } else if (currentP.axisDirection === 'vertical') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const centerX = canvas.width / 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.moveTo(centerX, 0);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.lineTo(centerX, canvas.height);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.stroke();
Â  Â  Â  Â  Â  Â  Â  Â  } else if (currentP.axisDirection === 'horizontal') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const centerY = canvas.height / 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.moveTo(0, centerY);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.lineTo(canvas.width, centerY);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.stroke();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  } else if (currentP.type === 'point') {
Â  Â  Â  Â  Â  Â  Â  Â  const centerX = canvas.width / 2;
Â  Â  Â  Â  Â  Â  Â  Â  const centerY = canvas.height / 2;
Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = '#ff0000';
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fill();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }

Â  Â  function drawLines(lines, color) {
Â  Â  Â  Â  ctx.strokeStyle = color;
Â  Â  Â  Â  ctx.lineWidth = 3;
Â  Â  Â  Â  lines.forEach(line => {
Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  ctx.moveTo(line.p1.x * GRID_SIZE, line.p1.y * GRID_SIZE);
Â  Â  Â  Â  Â  Â  ctx.lineTo(line.p2.x * GRID_SIZE, line.p2.y * GRID_SIZE);
Â  Â  Â  Â  Â  Â  ctx.stroke();
Â  Â  Â  Â  });
Â  Â  }

Â  Â  function redrawCanvas() {
Â  Â  Â  Â  ctx.clearRect(0, 0, canvas.width, canvas.height);
Â  Â  Â  Â  drawGrid();

Â  Â  Â  Â  drawLines(problemLines, '#007bff');
Â  Â  Â  Â  drawLines(userLines, '#28a745');
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (hoveredLine) {
Â  Â  Â  Â  Â  Â  ctx.save();
Â  Â  Â  Â  Â  Â  ctx.strokeStyle = 'rgba(234, 153, 153, 0.5)';
Â  Â  Â  Â  Â  Â  ctx.lineWidth = 8;
Â  Â  Â  Â  Â  Â  ctx.shadowColor = 'rgba(234, 153, 153, 0.7)';
Â  Â  Â  Â  Â  Â  ctx.shadowBlur = 10;
Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  ctx.moveTo(hoveredLine.p1.x * GRID_SIZE, hoveredLine.p1.y * GRID_SIZE);
Â  Â  Â  Â  Â  Â  ctx.lineTo(hoveredLine.p2.x * GRID_SIZE, hoveredLine.p2.y * GRID_SIZE);
Â  Â  Â  Â  Â  Â  ctx.stroke();
Â  Â  Â  Â  Â  Â  ctx.restore();
Â  Â  Â  Â  }

Â  Â  Â  Â  renderProblemVertices();

Â  Â  Â  Â  if (canvasMode === 'line') {
Â  Â  Â  Â  Â  Â  renderPointsForLineMode();
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  renderUserVertices();
Â  Â  Â  Â  }
Â  Â  }

Â  Â  function renderPointsForLineMode() {
Â  Â  Â  Â  document.querySelectorAll('.user-dot, .line-dot, .selected-line-dot').forEach(dot => dot.remove());

Â  Â  Â  Â  const allPoints = [...problemVertices, ...userVertices].filter((v, i, self) => i === self.findIndex(t => isSamePoint(t, v)));
Â  Â  Â  Â Â 
Â  Â  Â  Â  allPoints.forEach((v) => {
Â  Â  Â  Â  Â  Â  const dot = document.createElement('div');
Â  Â  Â  Â  Â  Â  dot.className = (tempLineStart && isSamePoint(v, tempLineStart)) ? 'selected-line-dot' : 'line-dot';
Â  Â  Â  Â  Â  Â  dot.style.left = `${(v.x / GRID_COUNT) * 100}%`;
Â  Â  Â  Â  Â  Â  dot.style.top = `${(v.y / GRID_COUNT) * 100}%`;
Â  Â  Â  Â  Â  Â  canvasWrapper.appendChild(dot);
Â  Â  Â  Â  });
Â  Â  }

Â  Â  function renderUserVertices() {
Â  Â  Â  Â  document.querySelectorAll('.user-dot, .line-dot, .selected-line-dot').forEach(dot => dot.remove());

Â  Â  Â  Â  userVertices.forEach((v) => {
Â  Â  Â  Â  Â  Â  const dot = document.createElement('div');
Â  Â  Â  Â  Â  Â  dot.className = 'user-dot';
Â  Â  Â  Â  Â  Â  dot.style.left = `${(v.x / GRID_COUNT) * 100}%`;
Â  Â  Â  Â  Â  Â  dot.style.top = `${(v.y / GRID_COUNT) * 100}%`;
Â  Â  Â  Â  Â  Â  canvasWrapper.appendChild(dot);
Â  Â  Â  Â  });
Â  Â  }

Â  Â  function isVertexOnProblemBoundary(v) {
Â  Â  Â  Â  return problemVertices.some(pv => isSamePoint(pv, v));
Â  Â  }
Â  Â Â 
Â  Â  function showPopup(mainMessage, detailMessage, isCorrect) {
Â  Â  Â  Â  const popupOverlay = document.getElementById('result-popup-overlay');
Â  Â  Â  Â  const popupMainMessage = document.getElementById('popup-main-message');
Â  Â  Â  Â  const popupDetailMessage = document.getElementById('popup-detail-message');
Â  Â  Â  Â  const popupNextBtn = document.getElementById('popup-next-btn');

Â  Â  Â  Â  if (isCorrect) {
Â  Â  Â  Â  Â  Â  popupMainMessage.innerHTML = mainMessage;
Â  Â  Â  Â  Â  Â  popupMainMessage.className = 'correct';
Â  Â  Â  Â  Â  Â  popupDetailMessage.style.display = 'none';
Â  Â  Â  Â  Â  Â  popupNextBtn.style.display = 'block';
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  popupMainMessage.innerHTML = `${mainMessage}<br><span style="font-size: 80%;">${detailMessage}</span>`;
Â  Â  Â  Â  Â  Â  popupMainMessage.className = 'incorrect';
Â  Â  Â  Â  Â  Â  popupDetailMessage.style.display = 'none';
Â  Â  Â  Â  Â  Â  popupNextBtn.style.display = 'none';
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  popupOverlay.style.display = 'flex';
Â  Â  }

Â  Â  function closePopup() {
Â  Â  Â  Â  document.getElementById('result-popup-overlay').style.display = 'none';
Â  Â  }
Â  Â Â 
Â  Â  function checkAnswer() {
Â  Â  Â  Â  const currentP = problemList[currentProblem];
Â  Â  Â  Â  if (!currentP) return false;
Â  Â  Â  Â  const problemType = currentP.type;
Â  Â  Â  Â  let verticesAreCorrect = checkVerticesSymmetry(problemType), isLinesCorrect = false;
Â  Â  Â  Â  if (verticesAreCorrect) {
Â  Â  Â  Â  Â  Â  if (problemType === 'line') isLinesCorrect = checkLineSymmetryLines(currentP);
Â  Â  Â  Â  Â  Â  else if (problemType === 'point') isLinesCorrect = checkPointSymmetryLines(currentP);
Â  Â  Â  Â  }
Â  Â  Â  Â  if (verticesAreCorrect && isLinesCorrect) {
Â  Â  Â  Â  Â  Â  if (score.results.length === currentProblem) {
Â  Â  Â  Â  Â  Â  Â  Â  score.results.push(currentProblemAttempts);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  showPopup('ì •ë‹µì…ë‹ˆë‹¤ğŸ‰', '', true);
Â  Â  Â  Â  Â  Â  saveGameState();
Â  Â  Â  Â  Â  Â  document.getElementById('check-answer-btn').style.display = 'none';
Â  Â  Â  Â  Â  Â  document.getElementById('next-problem-btn').style.display = 'block';
Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  let detailMessage;
Â  Â  Â  Â  Â  Â  if (!verticesAreCorrect) detailMessage = 'ê¼­ì§“ì ì˜ ìœ„ì¹˜ë‚˜ ê°œìˆ˜ê°€ ì˜ëª»ë˜ì—ˆì–´ìš”.';
Â  Â  Â  Â  Â  Â  else if (!isLinesCorrect) detailMessage = 'ë„í˜•ì´ ëŒ€ì¹­ì„ ì´ë£¨ì§€ ì•Šê±°ë‚˜ ë¹ ëœ¨ë¦° ì„ ë¶„ì´ ìˆì–´ìš”.';
Â  Â  Â  Â  Â  Â  else detailMessage = 'ê¼­ì§“ì ì´ë‚˜ ì„ ë¶„ ì—°ê²°ì— ì˜¤ë¥˜ê°€ ìˆì–´ ëŒ€ì¹­ë„í˜•ì´ ì™„ì„±ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.';
Â  Â  Â  Â  Â  Â  currentProblemAttempts++;
Â  Â  Â  Â  Â  Â  saveGameState();
Â  Â  Â  Â  Â  Â  showPopup('ë‹¤ì‹œ ìƒê°í•´ ë³¼ê¹Œìš”?', detailMessage, false);
Â  Â  Â  Â  Â  Â  document.getElementById('check-answer-btn').style.display = 'block';
Â  Â  Â  Â  Â  Â  document.getElementById('next-problem-btn').style.display = 'none';
Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  }
Â  Â  }

Â  Â  function checkVerticesSymmetry(problemType) { const currentP = problemList[currentProblem]; const isSlantedAxis = (currentP.type === 'line' && currentP.isSlantedAxis); const allProblemAndUserVerticesSet = new Map(); [...problemVertices, ...userVertices].forEach(v => { const key = `${Math.round(v.x)},${Math.round(v.y)}`; if (!allProblemAndUserVerticesSet.has(key)) allProblemAndUserVerticesSet.set(key, { x: Math.round(v.x), y: Math.round(v.y) }); }); const finalVertices = Array.from(allProblemAndUserVerticesSet.values()); if (problemType === 'line') { let boundaryVerticesCount; if (isSlantedAxis) boundaryVerticesCount = finalVertices.filter(v => v.x === v.y).length; else if (currentP.axisDirection === 'vertical') boundaryVerticesCount = finalVertices.filter(v => v.x === HALF_COUNT).length; else if (currentP.axisDirection === 'horizontal') boundaryVerticesCount = finalVertices.filter(v => v.y === HALF_COUNT).length; if ((finalVertices.length - boundaryVerticesCount) % 2 !== 0) return false; } let symmetricPairs = new Map(); for (const v of finalVertices) { const key = `${v.x},${v.y}`; if (symmetricPairs.has(key)) continue; const symmetricV = calculateSymmetricPoint(v, problemType, isSlantedAxis, currentP.axisDirection); if (isSamePoint(v, symmetricV)) { symmetricPairs.set(key, true); continue; } if (!finalVertices.some(av => isSamePoint(av, symmetricV))) return false; symmetricPairs.set(key, true); symmetricPairs.set(`${symmetricV.x},${symmetricV.y}`, true); } return true; }
Â  Â  function checkLineSymmetryLines(currentP) { const correctSymmetricLines = currentP.initialLines.map(line => ({ p1: calculateSymmetricPoint(line.p1, 'line', currentP.isSlantedAxis, currentP.axisDirection), p2: calculateSymmetricPoint(line.p2, 'line', currentP.isSlantedAxis, currentP.axisDirection) })); if (userLines.length !== correctSymmetricLines.length) return false; for (const userLine of userLines) if (!correctSymmetricLines.some(correctLine => isSameLine(userLine, correctLine))) return false; return true; }
Â  Â  function checkPointSymmetryLines(currentP) { const allDrawnLines = [...problemLines, ...userLines], correctLines = currentP.allLines; if (allDrawnLines.length !== correctLines.length) return false; const correctLinesCopy = [...correctLines]; for (const drawnLine of allDrawnLines) { const matchIndex = correctLinesCopy.findIndex(correctLine => isSameLine(drawnLine, correctLine)); if (matchIndex === -1) return false; correctLinesCopy.splice(matchIndex, 1); } return correctLinesCopy.length === 0; }
Â  Â  function findClosestValidLinePoint(v) { const allTargetVertices = [...problemVertices, ...userVertices]; if (problemList.length > currentProblem && problemList[currentProblem].type === 'point') allTargetVertices.push(CENTER_POINT); let closestPoint = null, minDistSq = Infinity; for (const p of allTargetVertices) { const dist = distSq(v, p); if (dist < minDistSq) { minDistSq = dist; closestPoint = p; } } return closestPoint; }
Â  Â  function setCanvasMode(mode) { canvasMode = mode; const vertexBtn = document.getElementById('mode-vertex'), lineBtn = document.getElementById('mode-line'); vertexBtn.classList.remove('mode-btn-active'); lineBtn.classList.remove('mode-btn-active'); const canStartLineDrawing = userVertices.length >= 1 || problemVertices.length > 1; if (mode === 'vertex') { vertexBtn.classList.add('mode-btn-active'); tempLineStart = null; } else { lineBtn.classList.add('mode-btn-active'); vertexBtn.disabled = false; } document.getElementById('mode-line').disabled = !canStartLineDrawing; redrawCanvas(); }
Â  Â Â 
Â  Â  function getTargetTimeForProblem(problem) {
Â  Â  Â  Â  const isDiff2 = selectedDifficulty == 2;
Â  Â  Â  Â  if (problem.type === 'line') {
Â  Â  Â  Â  Â  Â  return isDiff2 ? 20 : 10;
Â  Â  Â  Â  } else { // point
Â  Â  Â  Â  Â  Â  return isDiff2 ? 90 : 60;
Â  Â  Â  Â  }
Â  Â  }

Â  Â  function showFinalResult() {
Â  Â  Â  Â  if (gameMode === 'timeAttack') {
Â  Â  Â  Â  Â  Â  stopTimer();
Â  Â  Â  Â  }
Â  Â  Â  Â  if (gameMode === 'timeAttack' && selectedDifficulty !== 'practice') {
Â  Â  Â  Â  Â  Â  Â  totalProblems = score.results.length;
Â  Â  Â  Â  }

Â  Â  Â  Â  saveGameState();
Â  Â  Â  Â  showPage('final-result-page');

Â  Â  Â  Â  // ì •í™•ë„ì™€ ìµœì¢… ì ìˆ˜ ê³„ì‚° ë¡œì§
Â  Â  Â  Â  let correctCount = 0;
Â  Â  Â  Â  let retriedCount = 0;
Â  Â  Â  Â  let totalWeightedScore = 0;
Â  Â  Â  Â  score.results.forEach(attempts => {
Â  Â  Â  Â  Â  Â  if (attempts === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  correctCount++;
Â  Â  Â  Â  Â  Â  Â  Â  totalWeightedScore += 1.0;
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  retriedCount++;
Â  Â  Â  Â  Â  Â  Â  Â  totalWeightedScore += Math.max(0, 1.0 - attempts * 0.4);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  Â  Â Â 
Â  Â  Â  Â  const total = score.results.length;Â 
Â  Â  Â  Â  const accuracy = total > 0 ? parseFloat(((totalWeightedScore / total) * 100).toFixed(1)) : 0;
Â  Â  Â  Â  finalAccuracyValue = accuracy;
Â  Â  Â  Â Â 
Â  Â  Â  Â  let finalScore = 0;
Â  Â  Â  Â Â 
Â  Â  Â  Â  const isPractice = selectedDifficulty === 'practice';

Â  Â  Â  Â  document.getElementById('final-result-title').textContent = isPractice ? 'ì—°ìŠµ ì™„ë£Œ' : 'í•™ìŠµ ì™„ë£Œ';
Â  Â  Â  Â  const scoreDisplay = document.querySelector('.score-display');
Â  Â  Â  Â  const hofButton = document.getElementById('show-hof-btn');

Â  Â  Â  Â  if(isPractice) {
Â  Â  Â  Â  Â  Â  scoreDisplay.style.display = 'none';
Â  Â  Â  Â  Â  Â  hofButton.style.display = 'none';
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  scoreDisplay.style.display = 'block';
Â  Â  Â  Â  Â  Â  hofButton.style.display = 'block';
Â  Â  Â  Â  }

Â  Â  Â  Â  if (gameMode === 'timeAttack' && !isPractice) {
Â  Â  Â  Â  Â  Â  const totalProblemsSolved = total;
Â  Â  Â  Â  Â  Â  document.getElementById('time-attack-avg-time').style.display = 'block';

Â  Â  Â  Â  Â  Â  if (totalProblemsSolved === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  finalScore = 0;
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('avg-time-display').textContent = 'N/A';
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  const totalTimeSpent = (timeLimitInMinutes * 60) - remainingTime;
Â  Â  Â  Â  Â  Â  Â  Â  const averageTimePerProblem = totalProblemsSolved > 0 ? totalTimeSpent / totalProblemsSolved : 0;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  let totalTargetTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < totalProblemsSolved; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const problem = problemList[i];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (problem.type === 'point') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (selectedDifficulty == 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â totalTargetTime += 90;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â totalTargetTime += 60;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else { // 'line' ë˜ëŠ” 'both'
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (selectedDifficulty == 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â totalTargetTime += 20;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â totalTargetTime += 10;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  const averageTargetTime = totalProblemsSolved > 0 ? totalTargetTime / totalProblemsSolved : 0;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  const speedRatio = averageTimePerProblem > 0 ? averageTargetTime / averageTimePerProblem : 0;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  const difficultyMultiplier = (selectedDifficulty == 2) ? 1.5 : 1.2;
Â  Â  Â  Â  Â  Â  Â  Â  finalScore = Math.round(speedRatio * (accuracy / 100) * 5000 * difficultyMultiplier);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('avg-time-display').textContent = averageTimePerProblem.toFixed(1);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } else { // Classic Mode or Practice
Â  Â  Â  Â  Â  Â  document.getElementById('time-attack-avg-time').style.display = 'none';
Â  Â  Â  Â  Â  Â  Â if (!isPractice) {
Â  Â  Â  Â  Â  Â  Â  Â  Â let typeMultiplier = 1.0;
Â  Â  Â  Â  Â  Â  Â  Â  Â if (selectedType === 'point') typeMultiplier = 1.1;
Â  Â  Â  Â  Â  Â  Â  Â  Â else if (selectedType === 'both') typeMultiplier = 1.05;
Â  Â  Â  Â  Â  Â  Â  Â  Â const difficultyMultiplier = (selectedDifficulty == 2) ? 1.5 : 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â finalScore = Math.round((total * accuracy) * difficultyMultiplier * typeMultiplier);
Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  }
Â  Â  Â  Â  finalScoreValue = finalScore;
Â  Â  Â  Â  document.getElementById('correct-count').textContent = correctCount;
Â  Â  Â  Â  document.getElementById('retried-count').textContent = retriedCount;
Â  Â  Â  Â  document.getElementById('final-accuracy').textContent = `${accuracy}%`;
Â  Â  Â  Â  if (!isPractice) {
Â  Â  Â  Â  Â  Â  document.getElementById('final-score').textContent = finalScore;
Â  Â  Â  Â  }
Â  Â  }

Â  Â  function handleCanvasMouseMove(event) { if (document.getElementById('check-answer-btn').style.display === 'none') { if (hoveredLine) { hoveredLine = null; canvas.style.cursor = 'default'; redrawCanvas(); } return; } const rect = canvas.getBoundingClientRect(); const mouseXRatio = (event.clientX - rect.left) / rect.width, mouseYRatio = (event.clientY - rect.top) / rect.height; const canvasX = mouseXRatio * canvas.width, canvasY = mouseYRatio * canvas.height, mousePoint = { x: canvasX / GRID_SIZE, y: canvasY / GRID_SIZE }; let bestLine = null, minDistSq = 0.25; for (const line of userLines) { const p1 = line.p1, p2 = line.p2, lineLengthSq = distSq(p1, p2); if (lineLengthSq === 0) continue; let t = ((mousePoint.x - p1.x) * (p2.x - p1.x) + (mousePoint.y - p1.y) * (p2.y - p1.y)) / lineLengthSq; if (t > 0.2 && t < 0.8) { const closestPointOnLine = { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) }; const distanceSq = distSq(mousePoint, closestPointOnLine); if (distanceSq < minDistSq) { minDistSq = distanceSq; bestLine = line; } } } if (!isSameLine(hoveredLine, bestLine)) { hoveredLine = bestLine; redrawCanvas(); } if (hoveredLine) canvas.style.cursor = 'pointer'; else if (canvasMode === 'line') canvas.style.cursor = 'pointer'; else canvas.style.cursor = 'crosshair'; }
Â  Â  function showQrPopup() { document.getElementById('qr-popup-overlay').style.display = 'flex'; }
Â  Â  function closeQrPopup() { document.getElementById('qr-popup-overlay').style.display = 'none'; }
Â  Â Â 
Â  Â  function showHofPopup() {
Â  Â  Â  Â  const messageEl = document.getElementById('hof-message');
Â  Â  Â  Â  const inputGroup = document.querySelector('.hof-input-group');
Â  Â  Â  Â  const classicTbody = document.querySelector('#hof-table-classic tbody');
Â  Â  Â  Â  const timeAttackTbody = document.querySelector('#hof-table-timeattack tbody');

Â  Â  Â  Â  if (hasSubmittedScore) {
Â  Â  Â  Â  Â  Â  inputGroup.style.display = 'none';
Â  Â  Â  Â  Â  Â  messageEl.textContent = 'ì´ë²ˆ í•™ìŠµ ê¸°ë¡ì€ ì´ë¯¸ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤.';
Â  Â  Â  Â  Â  Â  messageEl.style.color = 'blue';
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  inputGroup.style.display = 'block';
Â  Â  Â  Â  Â  Â  messageEl.textContent = '';
Â  Â  Â  Â  Â  Â  document.getElementById('hof-initial').value = '';
Â  Â  Â  Â  Â  Â  document.getElementById('hof-submit-btn').disabled = false;
Â  Â  Â  Â  }

Â  Â  Â  Â  classicTbody.innerHTML = '<tr><td colspan="3">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</td></tr>';
Â  Â  Â  Â  timeAttackTbody.innerHTML = '<tr><td colspan="3">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</td></tr>';
Â  Â  Â  Â  document.getElementById('hof-popup-overlay').style.display = 'flex';
Â  Â  Â  Â Â 
Â  Â  Â  Â  fetch(webAppUrl)
Â  Â  Â  Â  Â  Â  .then(response => response.json())
Â  Â  Â  Â  Â  Â  .then(data => {
Â  Â  Â  Â  Â  Â  Â  Â  populateHofTable(classicTbody, data.classic || [], 'í´ë˜ì‹');
Â  Â  Â  Â  Â  Â  Â  Â  populateHofTable(timeAttackTbody, data.timeAttack || [], 'íƒ€ì„ì–´íƒ');
Â  Â  Â  Â  Â  Â  })
Â  Â  Â  Â  Â  Â  .catch(error => {
Â  Â  Â  Â  Â  Â  Â  Â  classicTbody.innerHTML = '<tr><td colspan="3">ê¸°ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.</td></tr>';
Â  Â  Â  Â  Â  Â  Â  Â  timeAttackTbody.innerHTML = '<tr><td colspan="3">ê¸°ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.</td></tr>';
Â  Â  Â  Â  Â  Â  Â  Â  console.error('Error fetching leaderboard:', error);
Â  Â  Â  Â  Â  Â  });
Â  Â  }

Â  Â  function populateHofTable(tbody, data, modeName) {
Â  Â  Â  Â  tbody.innerHTML = '';
Â  Â  Â  Â  if (!data || data.length === 0) {
Â  Â  Â  Â  Â  Â  tbody.innerHTML = `<tr><td colspan="3">ì•„ì§ ë“±ë¡ëœ ${modeName} ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</td></tr>`;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  data.forEach(item => {
Â  Â  Â  Â  Â  Â  Â  Â  let initialStyle = '';
Â  Â  Â  Â  Â  Â  Â  Â  if (item.rank === 1) initialStyle = 'style="color: #d4af37; font-weight: bold; text-shadow: 0 0 4px #fff, 0 0 6px #ff0;"';
Â  Â  Â  Â  Â  Â  Â  Â  if (item.rank === 2) initialStyle = 'style="color: #c0c0c0; font-weight: bold; text-shadow: 0 0 3px #fff;"';
Â  Â  Â  Â  Â  Â  Â  Â  if (item.rank === 3) initialStyle = 'style="color: #cd7f32; font-weight: bold; text-shadow: 0 0 3px #fff;"';
Â  Â  Â  Â  Â  Â  Â  Â  const row = `<tr><td>${item.rank}</td><td ${initialStyle}>${item.initial} ${item.rank === 1 ? 'ğŸ¥‡' : item.rank === 2 ? 'ğŸ¥ˆ' : item.rank === 3 ? 'ğŸ¥‰' : ''}</td><td>${item.score}</td></tr>`;
Â  Â  Â  Â  Â  Â  Â  Â  tbody.innerHTML += row;
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }
Â  Â  }

Â  Â  function closeHofPopup() { document.getElementById('hof-popup-overlay').style.display = 'none'; }
Â  Â Â 
Â  Â  function saveGameState() {
Â  Â  Â  Â  if (document.getElementById('problem-page').style.display === 'block' && problemList.length === 0) {
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }
Â  Â  Â  Â  const gameState = { problemList, currentProblem, score, userVertices, userLines, canvasMode, selectedType, selectedDifficulty, totalProblems, currentProblemAttempts, finalScoreValue, hasSubmittedScore, gameMode, timeLimitInMinutes, remainingTime };
Â  Â  Â  Â  localStorage.setItem('quizState', JSON.stringify(gameState));
Â  Â  }
Â  Â Â 
Â  Â  function loadGameState() {
Â  Â  Â  Â  const savedStateString = localStorage.getItem('quizState');
Â  Â  Â  Â  if (!savedStateString) return 'none';

Â  Â  Â  Â  const savedState = JSON.parse(savedStateString);
Â  Â  Â  Â  if (!savedState || !savedState.problemList || !savedState.score || !savedState.gameMode) {
Â  Â  Â  Â  Â  Â  return 'none';
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  const isClassicInProgress = savedState.gameMode === 'classic' &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â savedState.totalProblems > 0 &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â savedState.currentProblem < savedState.totalProblems;

Â  Â  Â  Â  const isTimeAttackInProgress = savedState.gameMode === 'timeAttack' &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â savedState.remainingTime > 0;

Â  Â  Â  Â  if (isClassicInProgress || isTimeAttackInProgress) {
Â  Â  Â  Â  Â  Â  problemList = savedState.problemList;
Â  Â  Â  Â  Â  Â  currentProblem = savedState.currentProblem;
Â  Â  Â  Â  Â  Â  score = savedState.score;
Â  Â  Â  Â  Â  Â  canvasMode = savedState.canvasMode;
Â  Â  Â  Â  Â  Â  selectedType = savedState.selectedType;
Â  Â  Â  Â  Â  Â  selectedDifficulty = savedState.selectedDifficulty;
Â  Â  Â  Â  Â  Â  totalProblems = savedState.totalProblems;
Â  Â  Â  Â  Â  Â  currentProblemAttempts = savedState.currentProblemAttempts;
Â  Â  Â  Â  Â  Â  finalScoreValue = savedState.finalScoreValue;
Â  Â  Â  Â  Â  Â  hasSubmittedScore = savedState.hasSubmittedScore;
Â  Â  Â  Â  Â  Â  gameMode = savedState.gameMode;
Â  Â  Â  Â  Â  Â  timeLimitInMinutes = savedState.timeLimitInMinutes;
Â  Â  Â  Â  Â  Â  remainingTime = savedState.remainingTime;
Â  Â  Â  Â  Â  Â  userVertices = savedState.userVertices || [];
Â  Â  Â  Â  Â  Â  userLines = savedState.userLines || [];

Â  Â  Â  Â  Â  Â  if (gameMode === 'timeAttack' && remainingTime > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  startTimer(true);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return 'in-progress';
Â  Â  Â  Â  }

Â  Â  Â  Â  const isFinished = savedState.score.results.length > 0 ||Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â (savedState.gameMode === 'timeAttack' && savedState.remainingTime <= 0);

Â  Â  Â  Â  if (isFinished) {
Â  Â  Â  Â  Â  Â  Object.assign(window, savedState);Â 
Â  Â  Â  Â  Â  Â  return 'finished';
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  return 'none';
Â  Â  }

Â  Â  function clearGameState() { localStorage.removeItem('quizState'); }
Â  Â Â 
Â  Â  function submitScore() {Â 
Â  Â  Â  Â  const initialInput = document.getElementById('hof-initial'),Â 
Â  Â  Â  Â  Â  Â  Â  initial = initialInput.value,Â 
Â  Â  Â  Â  Â  Â  Â  submitBtn = document.getElementById('hof-submit-btn'),Â 
Â  Â  Â  Â  Â  Â  Â  messageEl = document.getElementById('hof-message');
Â  Â  Â  Â  if (!/^[A-Z]{3}$/.test(initial)) {Â 
Â  Â  Â  Â  Â  Â  messageEl.textContent = 'ì´ë‹ˆì…œì€ ì˜ì–´ ëŒ€ë¬¸ì 3ê¸€ìë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.';Â 
Â  Â  Â  Â  Â  Â  messageEl.style.color = 'red';Â 
Â  Â  Â  Â  Â  Â  return;Â 
Â  Â  Â  Â  }Â 
Â  Â  Â  Â  submitBtn.disabled = true;Â 
Â  Â  Â  Â  messageEl.textContent = 'ë“±ë¡ ì¤‘...';Â 
Â  Â  Â  Â  messageEl.style.color = '#333';Â 
Â  Â  Â  Â  const data = {Â 
Â  Â  Â  Â  Â  Â  initial,Â 
Â  Â  Â  Â  Â  Â  score: finalScoreValue,Â 
Â  Â  Â  Â  Â  Â  problems: problemList.length,Â 
Â  Â  Â  Â  Â  Â  accuracy: finalAccuracyValue,Â 
Â  Â  Â  Â  Â  Â  difficulty: selectedDifficulty,Â 
Â  Â  Â  Â  Â  Â  type: selectedType,Â 
Â  Â  Â  Â  Â  Â  mode: gameMode
Â  Â  Â  Â  };Â 
Â  Â  Â  Â  fetch(webAppUrl, {Â 
Â  Â  Â  Â  Â  Â  method: 'POST',Â 
Â  Â  Â  Â  Â  Â  cache: 'no-cache',Â 
Â  Â  Â  Â  Â  Â  headers: { 'Content-Type': 'application/json' },Â 
Â  Â  Â  Â  Â  Â  body: JSON.stringify(data)Â 
Â  Â  Â  Â  }).then(response => response.json()).then(result => {Â 
Â  Â  Â  Â  Â  Â  if (result.result === 'success') {Â 
Â  Â  Â  Â  Â  Â  Â  Â  hasSubmittedScore = true;Â 
Â  Â  Â  Â  Â  Â  Â  Â  saveGameState();Â 
Â  Â  Â  Â  Â  Â  Â  Â  messageEl.textContent = 'ì„±ê³µì ìœ¼ë¡œ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤!';Â 
Â  Â  Â  Â  Â  Â  Â  Â  messageEl.style.color = '#4B8134';Â 
Â  Â  Â  Â  Â  Â  Â  Â  document.querySelector('.hof-input-group').style.display = 'none';Â 
Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(showHofPopup, 1500);Â 
Â  Â  Â  Â  Â  Â  } else throw new Error(result.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜');Â 
Â  Â  Â  Â  }).catch(error => {Â 
Â  Â  Â  Â  Â  Â  messageEl.textContent = 'ë“±ë¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.';Â 
Â  Â  Â  Â  Â  Â  messageEl.style.color = 'red';Â 
Â  Â  Â  Â  Â  Â  submitBtn.disabled = false;Â 
Â  Â  Â  Â  Â  Â  console.error('Error submitting score:', error);Â 
Â  Â  Â  Â  });Â 
Â  Â  }
Â  Â Â 
Â  Â  function startTimer(isResuming = false) { stopTimer(); if (!isResuming) remainingTime = timeLimitInMinutes * 60; const timerDisplay = document.getElementById('timer-display'); timerDisplay.style.display = 'block'; updateTimerDisplay(); timerInterval = setInterval(() => { remainingTime--; updateTimerDisplay(); if (remainingTime <= 0) { stopTimer(); showFinalResult(); } }, 1000); }
Â  Â  function stopTimer() { clearInterval(timerInterval); timerInterval = null; }
Â  Â Â 
Â  Â  function updateTimerDisplay() {
Â  Â  Â  Â  const timerDisplay = document.getElementById('timer-display');
Â  Â  Â  Â  if (remainingTime < 0) remainingTime = 0;
Â  Â  Â  Â  const minutes = Math.floor(remainingTime / 60);
Â  Â  Â  Â  const seconds = remainingTime % 60;
Â  Â  Â  Â  timerDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
Â  Â  Â  Â  timerDisplay.classList.toggle('time-warning', remainingTime <= 60 && remainingTime > 0);
Â  Â  }

Â  Â  window.onload = () => {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  setupGrid();
Â  Â  Â  Â  Â  Â  const gameState = loadGameState();
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  if (gameState === 'finished') {
Â  Â  Â  Â  Â  Â  Â  Â  showFinalResult();
Â  Â  Â  Â  Â  Â  } else if (gameState === 'in-progress') {
Â  Â  Â  Â  Â  Â  Â  Â  showPage('problem-page');
Â  Â  Â  Â  Â  Â  Â  Â  loadProblem();
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  resetGame();
Â  Â  Â  Â  Â  Â  Â  Â  showPage('mode-selection-page');
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  initializeSetupListeners();
Â  Â  Â  Â  Â  Â  document.getElementById('classic-mode-btn').addEventListener('click', () => selectGameMode('classic'));
Â  Â  Â  Â  Â  Â  document.getElementById('time-attack-mode-btn').addEventListener('click', () => selectGameMode('timeAttack'));
Â  Â  Â  Â  Â  Â  document.getElementById('back-to-mode-select-btn').addEventListener('click', () => {
Â  Â  Â  Â  Â  Â  Â  Â  if (confirm('ì§„í–‰ ìƒí™©ì´ ì‚¬ë¼ì§‘ë‹ˆë‹¤. ì •ë§ë¡œ ì²« í˜ì´ì§€ë¡œ ëŒì•„ê°ˆê¹Œìš”?')) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  resetGame();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  showPage('mode-selection-page');
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  canvas.addEventListener('mousemove', handleCanvasMouseMove);
Â  Â  Â  Â  Â  Â  canvas.addEventListener('mouseleave', () => { if (hoveredLine) { hoveredLine = null; redrawCanvas(); } });

Â  Â  Â  Â  Â  Â  canvas.addEventListener('click', (event) => {
Â  Â  Â  Â  Â  Â  Â  Â  if (document.getElementById('check-answer-btn').style.display === 'none') return;
Â  Â  Â  Â  Â  Â  Â  Â  if (hoveredLine) { userLines = userLines.filter(line => !isSameLine(line, hoveredLine)); hoveredLine = null; handleCanvasMouseMove(event); redrawCanvas(); saveGameState(); return; }
Â  Â  Â  Â  Â  Â  Â  Â  const rect = canvas.getBoundingClientRect(); const mouseXRatio = (event.clientX - rect.left) / rect.width; const mouseYRatio = (event.clientY - rect.top) / rect.height; const gridX = Math.round(mouseXRatio * canvas.width / GRID_SIZE); const gridY = Math.round(mouseYRatio * canvas.height / GRID_SIZE); if (gridX < 0 || gridX > GRID_COUNT || gridY < 0 || gridY > GRID_COUNT) return; const clickedGridPoint = { x: gridX, y: gridY };
Â  Â  Â  Â  Â  Â  Â  Â  if (canvasMode === 'vertex') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (isVertexOnProblemBoundary(clickedGridPoint)) return;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const existingIndex = userVertices.findIndex(v => isSamePoint(v, clickedGridPoint));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (existingIndex > -1) { userVertices.splice(existingIndex, 1); userLines = userLines.filter(line => !(isSamePoint(line.p1, clickedGridPoint) || isSamePoint(line.p2, clickedGridPoint))); } else { userVertices.push(clickedGridPoint); }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  redrawCanvas();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  saveGameState();
Â  Â  Â  Â  Â  Â  Â  Â  } else if (canvasMode === 'line') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const targetPoint = findClosestValidLinePoint(clickedGridPoint); if (!targetPoint) return;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!tempLineStart) { tempLineStart = targetPoint; } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!isSamePoint(tempLineStart, targetPoint)) { const newLine = { p1: tempLineStart, p2: targetPoint }; if (!isLineExists(newLine)) userLines.push(newLine); else userLines = userLines.filter(existingLine => !isSameLine(existingLine, newLine)); }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tempLineStart = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  redrawCanvas();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  saveGameState();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  document.getElementById('start-quiz-btn').addEventListener('click', startQuiz);
Â  Â  Â  Â  Â  Â  document.getElementById('next-problem-btn').addEventListener('click', nextProblem);
Â  Â  Â  Â  Â  Â  document.getElementById('clear-canvas-btn').addEventListener('click', () => { document.getElementById('confirm-clear-popup-overlay').style.display = 'flex'; });
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  document.querySelector('#problem-page .home-button').addEventListener('click', () => {
Â  Â  Â  Â  Â  Â  Â  Â  if (confirm('ì§„í–‰ ìƒí™©ì´ ì‚¬ë¼ì§‘ë‹ˆë‹¤. ì •ë§ë¡œ ì²« í˜ì´ì§€ë¡œ ëŒì•„ê°ˆê¹Œìš”?')) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  resetGame();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  showPage('mode-selection-page');
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  document.getElementById('qr-code-btn').addEventListener('click', showQrPopup);
Â  Â  Â  Â  Â  Â  document.getElementById('show-hof-btn').addEventListener('click', showHofPopup);
Â  Â  Â  Â  Â  Â  document.getElementById('hof-submit-btn').addEventListener('click', submitScore);
Â  Â  Â  Â  Â  Â  document.getElementById('confirm-clear-yes-btn').addEventListener('click', () => { clearCanvas(true); saveGameState(); document.getElementById('confirm-clear-popup-overlay').style.display = 'none'; });
Â  Â  Â  Â  Â  Â  document.getElementById('confirm-clear-no-btn').addEventListener('click', () => { document.getElementById('confirm-clear-popup-overlay').style.display = 'none'; });
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  document.getElementById('restart-btn').addEventListener('click', () => {
Â  Â  Â  Â  Â  Â  Â  Â  resetGame();
Â  Â  Â  Â  Â  Â  Â  Â  showPage('mode-selection-page');
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const saveOnExit = () => { if (isExitingIntentionally) return; if (document.getElementById('problem-page').style.display === 'block') saveGameState(); };
Â  Â  Â  Â  Â  Â  window.addEventListener('pagehide', saveOnExit);
Â  Â  Â  Â  Â  Â  window.addEventListener('visibilitychange', () => { if (document.visibilityState === 'hidden') saveOnExit(); });

Â  Â  Â  Â  Â  Â  const checkAnswerBtn = document.getElementById('check-answer-btn');
Â  Â  Â  Â  Â  Â  const progressBar = checkAnswerBtn.querySelector('.progress-bar');
Â  Â  Â  Â  Â  Â  let pressTimer = null;
Â  Â  Â  Â  Â  Â  let isPressing = false;
Â  Â  Â  Â  Â  Â  const PRESS_AND_HOLD_DURATION = 400;

Â  Â  Â  Â  Â  Â  const startPress = (event) => {
Â  Â  Â  Â  Â  Â  Â  Â  if (event.type === 'mousedown' && event.button !== 0) return;
Â  Â  Â  Â  Â  Â  Â  Â  event.preventDefault();
Â  Â  Â  Â  Â  Â  Â  Â  if (isPressing) return;

Â  Â  Â  Â  Â  Â  Â  Â  isPressing = true;
Â  Â  Â  Â  Â  Â  Â  Â  progressBar.style.transition = `transform ${PRESS_AND_HOLD_DURATION / 1000}s linear`;
Â  Â  Â  Â  Â  Â  Â  Â  progressBar.style.transform = 'translateX(0%)';

Â  Â  Â  Â  Â  Â  Â  Â  pressTimer = setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!isPressing) return;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const isCorrect = checkAnswer();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!isCorrect) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cancelPress();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }, PRESS_AND_HOLD_DURATION);
Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â  const cancelPress = () => {
Â  Â  Â  Â  Â  Â  Â  Â  if (!isPressing) return;
Â  Â  Â  Â  Â  Â  Â  Â  isPressing = false;
Â  Â  Â  Â  Â  Â  Â  Â  clearTimeout(pressTimer);
Â  Â  Â  Â  Â  Â  Â  Â  pressTimer = null;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  progressBar.style.transition = 'transform 0.2s ease-out';
Â  Â  Â  Â  Â  Â  Â  Â  progressBar.style.transform = 'translateX(-100%)';
Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â  checkAnswerBtn.addEventListener('mousedown', startPress);
Â  Â  Â  Â  Â  Â  checkAnswerBtn.addEventListener('touchstart', startPress, { passive: false });
Â  Â  Â  Â  Â  Â  checkAnswerBtn.addEventListener('mouseup', cancelPress);
Â  Â  Â  Â  Â  Â  checkAnswerBtn.addEventListener('mouseleave', cancelPress);
Â  Â  Â  Â  Â  Â  checkAnswerBtn.addEventListener('touchend', cancelPress);
Â  Â  Â  Â  } catch (error) {
Â  Â  Â  Â  Â  Â  console.error("ì˜¤ë¥˜ê°€ ë°œìƒí•˜ì—¬ ì•±ì„ ì´ˆê¸°í™”í•©ë‹ˆë‹¤:", error);
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  clearGameState();Â 
Â  Â  Â  Â  Â  Â  // location.reload() might be too aggressive, let's try resetting state and UI first
Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  resetGame();
Â  Â  Â  Â  Â  Â  Â  Â  showPage('mode-selection-page');
Â  Â  Â  Â  Â  Â  Â  Â  initializeSetupListeners();
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('classic-mode-btn').addEventListener('click', () => selectGameMode('classic'));
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('time-attack-mode-btn').addEventListener('click', () => selectGameMode('timeAttack'));
Â  Â  Â  Â  Â  Â  } catch (recoveryError) {
Â  Â  Â  Â  Â  Â  Â  Â  console.error("ë³µêµ¬ ì¤‘ ì¶”ê°€ ì˜¤ë¥˜ ë°œìƒ:", recoveryError);
Â  Â  Â  Â  Â  Â  Â  Â  alert("ì¹˜ëª…ì ì¸ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ì—¬ í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•©ë‹ˆë‹¤.");
Â  Â  Â  Â  Â  Â  Â  Â  location.reload();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  };
</script>

</body>
</html>
